<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colliers Property Assistant</title>
    <style>
        body {
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: transparent;
        }
        
        .chat-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            border: 1px solid #DBE5FF;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        
        .chat-header {
            background-color: #25408F; /* Colliers Dark Blue */
            color: white;
            padding: 15px;
            font-weight: bold;
            text-align: center;
            position: relative;
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: #f8f8f8;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            clear: both;
        }
        
        .user-message {
            background-color: #1C54F4; /* Medium Blue */
            color: white;
            float: right;
        }
        
        .bot-message {
            background-color: #DBE5FF; /* Pale Blue Grey */
            color: #353E59; /* Deep Blue Grey */
            float: left;
        }
        
        .input-container {
            display: flex;
            padding: 15px;
            background-color: #fff;
            border-top: 1px solid #DBE5FF;
        }
        
        #user-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #DBE5FF;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 14px;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        #send-button {
            background-color: #25408F; /* Colliers Dark Blue */
            color: white;
            border: none;
            border-radius: 20px;
            padding: 0 20px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        #send-button:hover {
            background-color: #000759; /* Deep Blue */
        }
        
        .property-item {
            margin: 12px 0;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(37, 64, 143, 0.05);
            border-left: 3px solid #25408F; /* Colliers Dark Blue */
        }
        
        .property-name {
            font-weight: bold;
            color: #25408F; /* Colliers Dark Blue */
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .property-details {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .property-detail {
            background-color: #DBE5FF; /* Pale Blue Grey */
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.9em;
        }
        
        .typing-indicator {
            background-color: #DBE5FF; /* Pale Blue Grey */
            color: #353E59; /* Deep Blue Grey */
            padding: 8px 15px;
            border-radius: 18px;
            margin-bottom: 15px;
            display: inline-block;
            float: left;
            clear: both;
        }
        
        /* For iframe embedding, ensure proper sizing */
        @media (max-width: 500px) {
            .chat-container {
                max-width: 100%;
                max-height: 100%;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
        
        /* Clear floats after messages */
        .clearfix::after {
            content: "";
            clear: both;
            display: table;
        }
        
        /* Reset button */
        #reset-chat {
            position: absolute;
            right: 15px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.8;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        #reset-chat:hover {
            opacity: 1;
        }
        
        /* Suggestion Buttons */
        .suggestion-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }
        
        .suggestion-button {
            background-color: #DBE5FF; /* Pale Blue Grey */
            color: #25408F; /* Colliers Dark Blue */
            border: 1px solid #25408F;
            border-radius: 16px;
            padding: 6px 12px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        .suggestion-button:hover {
            background-color: #25408F; /* Colliers Dark Blue */
            color: white;
        }
        
        /* Refinement Buttons */
        .refinement-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 12px 0;
        }
        
        .refinement-button {
            background-color: #ACBBE8; /* Light Blue Grey */
            color: #353E59; /* Deep Blue Grey */
            border: 1px solid #7B8BBD; /* Medium Blue Grey */
            border-radius: 16px;
            padding: 6px 12px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        .refinement-button:hover {
            background-color: #7B8BBD; /* Medium Blue Grey */
            color: white;
        }
        
        /* Action Buttons (like "Show More") */
        .action-button {
            background-color: #25408F; /* Colliers Dark Blue */
            color: white;
            border: none;
            border-radius: 16px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
            display: inline-block;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        .action-button:hover {
            background-color: #000759; /* Deep Blue */
        }
        
        /* Active filters display */
        .active-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 12px 0;
            padding: 8px;
            background-color: #f8f8f8;
            border-radius: 8px;
        }
        
        .filter-tag {
            background-color: #C3E6FF; /* Pale Blue */
            color: #25408F; /* Colliers Dark Blue */
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            font-family: 'Open Sans', Verdana, Arial, sans-serif;
        }
        
        .filter-tag .remove {
            margin-left: 6px;
            font-weight: bold;
            cursor: pointer;
        }
        
        /* Step indicator for progressive conversations */
        .step-indicator {
            display: flex;
            justify-content: center;
            margin: 12px 0;
        }
        
        .step {
            width: 8px;
            height: 8px;
            background-color: #DBE5FF; /* Pale Blue Grey */
            border-radius: 50%;
            margin: 0 4px;
        }
        
        .step.active {
            background-color: #25408F; /* Colliers Dark Blue */
            width: 10px;
            height: 10px;
        }
        
        /* Debug panel styling */
        .debug-panel {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 12px;
            padding: 5px;
            overflow-y: auto;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            Colliers Property Assistant
            <button id="reset-chat">New Chat</button>
        </div>
        <div id="messages" class="messages-container"></div>
        <div class="input-container">
            <input type="text" id="user-input" placeholder="Ask about our properties...">
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <!-- Debug panel (for development) -->
    <div id="debug-panel" class="debug-panel"></div>
 <script>
        // Debug flag - set to true to show debug panel and logs
        const DEBUG_MODE = true;
        
        // Initialize properties array
        let properties = [];
        let propertiesLoaded = false;
        
        // Conversation history - store the entire conversation
        let conversationHistory = [];

        // Conversation state - track state across interactions
        let conversationState = {
            currentSearchCriteria: null,
            lastShownProperties: [],
            offset: 0, // For pagination of results
            lastQuery: "",
            lastResponse: ""
        };

        // Gemini API Configuration
        const GEMINI_API_KEY = "AIzaSyBu8k9YArazXs1MXrKzxctJiYz85LMD850";
        const GEMINI_MODEL = "gemini-2.0-flash";
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";

        // Debug logger function
        function debugLog(message, obj = null) {
            if (DEBUG_MODE) {
                console.log(message, obj || '');
                
                const panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.style.display = 'block';
                    
                    const logEntry = document.createElement('div');
                    logEntry.textContent = `${new Date().toISOString().substr(11, 8)} - ${message}`;
                    
                    if (obj) {
                        const objStr = typeof obj === 'string' ? obj : JSON.stringify(obj);
                        if (objStr.length > 200) {
                            logEntry.textContent += ` ${objStr.substr(0, 200)}...`;
                        } else {
                            logEntry.textContent += ` ${objStr}`;
                        }
                    }
                    
                    panel.appendChild(logEntry);
                    panel.scrollTop = panel.scrollHeight;
                    
                    // Limit entries to prevent browser slowdown
                    while (panel.childElementCount > 100) {
                        panel.removeChild(panel.firstChild);
                    }
                }
            }
        }

        // Helper function to determine if input is Czech
        function isCzech(text) {
            return /[áčďéěíňóřšťúůýž]/i.test(text);
        }

        // Function to load properties from JSON file
        async function loadProperties() {
            try {
                debugLog("Loading properties from JSON file...");
                const loadingMessage = addMessage("Loading property listings...", 'bot');
                
                const response = await fetch('properties.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                properties = await response.json();
                propertiesLoaded = true;
                
                debugLog(`Successfully loaded ${properties.length} properties`);
                loadingMessage.innerHTML = `Property listings loaded successfully! I now have information about ${properties.length} properties.`;
                
                return true;
            } catch (error) {
                debugLog("Error loading properties:", error.message);
                const loadingMessage = document.querySelector('.bot-message:last-child');
                if (loadingMessage) {
                    loadingMessage.innerHTML = "I'm having trouble loading the property listings. Please try again later.";
                }
                return false;
            }
        }
     // Add welcome message and load properties when page loads
        window.addEventListener('load', async function() {
            // Add welcome message
            const welcomeMessage = "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?<br><br><button class='action-button' onclick='startProgressiveConversation()'>Start Guided Search</button>";
            addMessage(welcomeMessage, 'bot');
            
            // Add to conversation history (without the HTML)
            conversationHistory.push({role: "assistant", content: "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?"});
            
            // Load properties
            await loadProperties();
            
            if (DEBUG_MODE) {
                debugLog("Debug mode enabled. Showing debug panel.");
                document.getElementById('debug-panel').style.display = 'block';
            }
        });

        // Reset chat button - UPDATED to clear conversation state
        document.getElementById('reset-chat').addEventListener('click', function() {
            // Clear conversation history
            conversationHistory = [];
            
            // Reset conversation state
            conversationState = {
                currentSearchCriteria: null,
                lastShownProperties: [],
                offset: 0,
                lastQuery: "",
                lastResponse: ""
            };
            
            // Clear messages
            document.getElementById('messages').innerHTML = '';
            
            // Add welcome message
            const welcomeMessage = "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?<br><br><button class='action-button' onclick='startProgressiveConversation()'>Start Guided Search</button>";
            addMessage(welcomeMessage, 'bot');
            
            // Add to conversation history
            conversationHistory.push({role: "assistant", content: "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?"});
            
            debugLog("Chat reset, conversation state cleared");
        });

        // Send button click event
        document.getElementById('send-button').addEventListener('click', function() {
            const input = document.getElementById('user-input').value.trim().toLowerCase();
            
            if (input === "!test api") {
                document.getElementById('user-input').value = '';
                testGeminiAPI();
                return; // Add return statement to prevent normal message processing
            } else {
                sendMessage();
            }
        });

        // Enter key press event
        document.getElementById('user-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const input = document.getElementById('user-input').value.trim().toLowerCase();
                if (input === "!test api") {
                    document.getElementById('user-input').value = '';
                    testGeminiAPI();
                    return; // Add return statement to prevent normal message processing
                }
                sendMessage();
            }
        });

        // Improved follow-up detection
        function isFollowUpQuestion(userInput) {
            // First, check for obvious follow-up phrases
            const followUpPhrases = /more|additional|another|further|similar|like that|such|tell me more|show more|any other|else|next|other|další|více|ještě|také|další|podobné/i;
            
            if (followUpPhrases.test(userInput)) {
                return true;
            }
            
            // Check for very short queries that likely reference previous context
            if (userInput.split(/\s+/).length < 4 && conversationState.currentSearchCriteria) {
                return true;
            }
            
            // Check for queries that only specify one parameter but we have other parameters saved
            const hasOnlySize = /\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)/i.test(userInput) && 
                               !/office|retail|industrial|prague|brno|ostrava|kancelář|obchod|průmysl/i.test(userInput);
            
            const hasOnlyLocation = /prague|praha|brno|ostrava/i.test(userInput) && 
                                   !/\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)|office|retail|industrial|kancelář|obchod|průmysl/i.test(userInput);
            
            const hasOnlyType = /office|retail|industrial|kancelář|obchod|průmysl/i.test(userInput) && 
                                !/\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)|prague|praha|brno|ostrava/i.test(userInput);
            
            if ((hasOnlySize || hasOnlyLocation || hasOnlyType) && conversationState.currentSearchCriteria) {
                return true;
            }
            
            return false;
        }
     // Extract search criteria from user input
function extractSearchCriteria(userInput, previousCriteria = null) {
    debugLog("Extracting search criteria from:", userInput);
    let criteria = previousCriteria ? {...previousCriteria} : {};
    
    // Extract location
    if (/prague|praha/i.test(userInput)) {
        // Handle Prague and its districts
        criteria.location = "Prague";
        
        // Look for Praha/Prague followed by a number (district)
        const pragueDistrictMatches = userInput.match(/prague\s*(\d+)|praha\s*(\d+)/gi);
        if (pragueDistrictMatches && pragueDistrictMatches.length > 0) {
            // If we found district numbers, use the full match as the location
            // This will preserve "Prague 1 or Prague 2" type queries
            if (userInput.toLowerCase().includes(' or ') && pragueDistrictMatches.length > 1) {
                // Multiple districts with "or" - capture the whole phrase
                let districtPhrase = "Prague";
                pragueDistrictMatches.forEach(match => {
                    const distNum = match.match(/\d+/)[0];
                    districtPhrase += ` ${distNum} or Prague`;
                });
                // Remove the trailing " or Prague"
                districtPhrase = districtPhrase.replace(/ or Prague$/, '');
                criteria.location = districtPhrase;
            } else {
                // Single district or no "or" connector
                const firstMatch = pragueDistrictMatches[0];
                const distNum = firstMatch.match(/\d+/)[0];
                criteria.location = `Prague ${distNum}`;
            }
        }
    } else if (/brno/i.test(userInput)) {
        criteria.location = "Brno";
    } else if (/ostrava/i.test(userInput)) {
        criteria.location = "Ostrava";
    }
    
    // Extract property type
    if (/office|kancelář/i.test(userInput)) {
        criteria.type = "office";
    } else if (/retail|obchod/i.test(userInput)) {
        criteria.type = "retail";
    } else if (/industrial|průmysl|sklad/i.test(userInput)) {
        criteria.type = "industrial";
    }
    
    // IMPROVED: Check for people-based sizing with more patterns
    const peopleMatch = userInput.match(/(\d+)\s*(?:people|persons|employees|staff|workers|colleagues|team members|osoby|lidí|zaměstnanců|pracovníků)/i) ||
                        userInput.match(/(?:space|office|workspace|property|prostory|kanceláře)\s+for\s+(\d+)/i) || 
                        userInput.match(/(?:help me size|help with size|pomoc s velikostí).*?(\d+)/i);
    
    if (peopleMatch) {
        const numberOfPeople = parseInt(peopleMatch[1]);
        if (!isNaN(numberOfPeople)) {
            // Flag that this is a people-based query that needs Gemini processing
            criteria.peopleCount = numberOfPeople;
            debugLog(`Detected people-based query: ${numberOfPeople} people`);
        }
    }
    
    // Extract size "between X and Y" pattern
    const betweenMatch = userInput.match(/between\s+(\d+)\s+and\s+(\d+)/i) || 
                       userInput.match(/from\s+(\d+)\s+to\s+(\d+)/i);
    
    if (betweenMatch) {
        criteria.minSize = betweenMatch[1];
        criteria.maxSize = betweenMatch[2];
        debugLog(`Detected size range: ${criteria.minSize}-${criteria.maxSize} sqm`);
    } else {
        // If no "between" pattern, check for individual size specifications
        
        // Check for size
        const sizeMatch = userInput.match(/(\d+)\s*(?:sq\s*m|sqm|square meter|m2|metr)/i);
        if (sizeMatch) {
            criteria.size = sizeMatch[1];
        }
        
        // Check for "less than" or "under" size specification
        const underSizeMatch = userInput.match(/(?:less than|under|smaller than|max|maximum|do|méně než|pod|maximálně)\s*(\d+)/i);
        if (underSizeMatch) {
            criteria.maxSize = underSizeMatch[1];
        }
        
        // Check for "more than" or "over" size specification
        const overSizeMatch = userInput.match(/(?:more than|over|larger than|min|minimum|nad|více než|minimálně)\s*(\d+)/i);
        if (overSizeMatch) {
            criteria.minSize = overSizeMatch[1];
        }
    }
    
    // Check for availability mentions
    if (/available|now|immediately|ihned|dostupn/i.test(userInput)) {
        criteria.available = "now";
    } else if (/q[1-4]|quarter|quartal|kvartál|202[0-9]/i.test(userInput)) {
        criteria.available = ""; // Just flag that specific availability is important
    }
    
    debugLog("Extracted search criteria:", criteria);
    return criteria;
}

// Enhanced search function with proper Prague district handling
function enhancedSearchProperties(criteria) {
    debugLog("Searching properties with criteria:", criteria);
    let results = [...properties];
    
    // First, handle Prague district special case
    if (criteria.location && criteria.location.toLowerCase().includes('prague')) {
        debugLog("Processing Prague district search");
        
        // Extract district number if present
        const pragueDistrictMatch = criteria.location.match(/prague\s*(\d+)/i);
        const pragueDistricts = [];
        
        if (pragueDistrictMatch && pragueDistrictMatch[1]) {
            // If a specific district is mentioned, add it to the array
            pragueDistricts.push(pragueDistrictMatch[1]);
            debugLog(`Looking specifically for Prague district ${pragueDistrictMatch[1]}`);
            
            // Handle "Prague 1 or Prague 2" type queries by checking for multiple districts
            if (criteria.location.toLowerCase().includes('or')) {
                const additionalDistricts = criteria.location.toLowerCase().match(/prague\s*(\d+)/gi);
                if (additionalDistricts && additionalDistricts.length > 1) {
                    for (let districtMatch of additionalDistricts) {
                        const distNum = districtMatch.match(/prague\s*(\d+)/i)[1];
                        if (!pragueDistricts.includes(distNum)) {
                            pragueDistricts.push(distNum);
                        }
                    }
                    debugLog(`Multiple Prague districts requested: ${pragueDistricts.join(', ')}`);
                }
            }
        }
        
        // Filter for Prague properties with matching district if districts specified
        if (pragueDistricts.length > 0) {
            results = results.filter(p => {
                // First check that this is a Prague property
                const isPrague = (p.city && p.city.toLowerCase().includes('prague')) || 
                                (p.location && p.location.toLowerCase().includes('prague'));
                
                if (!isPrague) return false;
                
                // Then check for district match
                let districtMatch = false;
                
                // Check in the district field if it exists
                if (p.district) {
                    // Extract district number from property district field
                    const propertyDistrictMatch = p.district.match(/(\d+)/);
                    if (propertyDistrictMatch && propertyDistrictMatch[1]) {
                        districtMatch = pragueDistricts.includes(propertyDistrictMatch[1]);
                    }
                }
                
                // Also check in the location field for district info
                if (!districtMatch && p.location) {
                    const locationDistrictMatch = p.location.match(/prague\s*(\d+)/i);
                    if (locationDistrictMatch && locationDistrictMatch[1]) {
                        districtMatch = pragueDistricts.includes(locationDistrictMatch[1]);
                    }
                }
                
                return districtMatch;
            });
            
            debugLog(`After Prague district filter: ${results.length} properties remaining`);
        } else {
            // If just "Prague" with no district, filter for any Prague property
            results = results.filter(p => {
                return (p.city && p.city.toLowerCase().includes('prague')) || 
                      (p.location && p.location.toLowerCase().includes('prague'));
            });
            debugLog(`After Prague city filter: ${results.length} properties remaining`);
        }
    } 
    // Handle non-Prague city search
    else if (criteria.location) {
        const locationKeywords = criteria.location.toLowerCase().split(/\s+/);
        results = results.filter(p => {
            const propertyLocation = (p.location || "").toLowerCase();
            const propertyCity = (p.city || "").toLowerCase();
            
            return locationKeywords.some(keyword => 
                propertyLocation.includes(keyword) || 
                propertyCity.includes(keyword)
            );
        });
        debugLog(`After location filter: ${results.length} properties remaining`);
    }
    
    // Filter by property type
    if (criteria.type) {
        const typeKeywords = criteria.type.toLowerCase().split(/\s+/);
        results = results.filter(p => {
            if (!p.type) return false;
            const propertyType = p.type.toLowerCase();
            return typeKeywords.some(keyword => propertyType.includes(keyword));
        });
        debugLog(`After type filter: ${results.length} properties remaining`);
    }
    
    // Enhanced size filtering logic
    const handleSizeFiltering = () => {
        // Handle size range queries (between X and Y)
        if (criteria.minSize && criteria.maxSize) {
            const minSize = parseInt(criteria.minSize);
            const maxSize = parseInt(criteria.maxSize);
            
            if (!isNaN(minSize) && !isNaN(maxSize)) {
                results = results.filter(p => {
                    const propertySize = parseInt(p.size);
                    return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                });
                debugLog(`After size range filter (${minSize}-${maxSize}): ${results.length} properties remaining`);
            }
        }
        // Handle approximate size with tolerance
        else if (criteria.size) {
            const targetSize = parseInt(criteria.size);
            if (!isNaN(targetSize)) {
                const minSize = targetSize * 0.8;
                const maxSize = targetSize * 1.2;
                
                results = results.filter(p => {
                    const propertySize = parseInt(p.size);
                    return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                });
                debugLog(`After approximate size filter (${criteria.size}): ${results.length} properties remaining`);
            }
        }
        // Handle explicit max size only
        else if (criteria.maxSize) {
            const maxSize = parseInt(criteria.maxSize);
            if (!isNaN(maxSize)) {
                results = results.filter(p => {
                    const propertySize = parseInt(p.size);
                    return !isNaN(propertySize) && propertySize <= maxSize;
                });
                debugLog(`After maxSize filter (${criteria.maxSize}): ${results.length} properties remaining`);
            }
        }
        // Handle explicit min size only
        else if (criteria.minSize) {
            const minSize = parseInt(criteria.minSize);
            if (!isNaN(minSize)) {
                results = results.filter(p => {
                    const propertySize = parseInt(p.size);
                    return !isNaN(propertySize) && propertySize >= minSize;
                });
                debugLog(`After minSize filter (${criteria.minSize}): ${results.length} properties remaining`);
            }
        }
    };
    
    handleSizeFiltering();
    // Handle "between X and Y" size queries from natural language
    if (!criteria.minSize && !criteria.maxSize && !criteria.size) {
        // Look for patterns like "between 400 and 500" or "from 400 to 500"
        const userQuery = conversationState.lastQuery.toLowerCase();
        const betweenMatch = userQuery.match(/between\s+(\d+)\s+and\s+(\d+)/i) || 
                           userQuery.match(/from\s+(\d+)\s+to\s+(\d+)/i);
        
        if (betweenMatch) {
            const minSize = parseInt(betweenMatch[1]);
            const maxSize = parseInt(betweenMatch[2]);
            
            if (!isNaN(minSize) && !isNaN(maxSize)) {
                results = results.filter(p => {
                    const propertySize = parseInt(p.size);
                    return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                });
                debugLog(`After "between ${minSize} and ${maxSize}" filter: ${results.length} properties remaining`);
            }
        }
    }
    
    // Filter by availability - ONLY if not "Any"
    if (criteria.available && criteria.available.toLowerCase() !== 'any') {
        const availableKeywords = criteria.available.toLowerCase().split(/\s+/);
        results = results.filter(p => {
            if (!p.available) return false;
            const propertyAvailable = p.available.toLowerCase();
            return availableKeywords.some(keyword => propertyAvailable.includes(keyword));
        });
        debugLog(`After availability filter: ${results.length} properties remaining`);
    } else {
        debugLog("Availability filter skipped (set to 'Any' or not specified)");
}
    
    // Exclude specific properties if needed
    if (criteria.excludeNames && criteria.excludeNames.length > 0) {
        results = results.filter(p => !criteria.excludeNames.includes(p.name));
        debugLog(`After exclusion filter: ${results.length} properties remaining`);
    }
    
// If no results and we have size criteria, try with more relaxed constraints
if (results.length === 0 && (criteria.size || criteria.minSize || criteria.maxSize)) {
    debugLog("No results with strict criteria, trying with relaxed constraints");
    
    // Save original results count for later
    const originalResultsCount = results.length;
    
    // Reset results
    results = [...properties];
    
    // Reapply non-size filters - KEEP PRAGUE DISTRICT FILTER STRICT
    if (criteria.type) {
        const typeKeywords = criteria.type.toLowerCase().split(/\s+/);
        results = results.filter(p => {
            if (!p.type) return false;
            const propertyType = p.type.toLowerCase();
            return typeKeywords.some(keyword => propertyType.includes(keyword));
        });
    }
    
    // IMPORTANT: Preserve the Prague district filter even in relaxed mode
    if (criteria.location) {
        if (criteria.location.toLowerCase().includes('prague')) {
            // Handle Prague district special case - KEEP STRICT
            const pragueDistrictMatch = criteria.location.match(/prague\s*(\d+)/i);
            if (pragueDistrictMatch && pragueDistrictMatch[1]) {
                // We found a Prague district, DO NOT RELAX this constraint
                const districtNum = pragueDistrictMatch[1];
                results = results.filter(p => {
                    // Look for district in district field
                    if (p.district) {
                        const propertyDistrictMatch = p.district.match(/(\d+)/);
                        if (propertyDistrictMatch && propertyDistrictMatch[1] === districtNum) {
                            return true;
                        }
                    }
                    
                    // Also check location field
                    if (p.location) {
                        const locationDistrictMatch = p.location.match(/prague\s*(\d+)/i);
                        if (locationDistrictMatch && locationDistrictMatch[1] === districtNum) {
                            return true;
                        }
                    }
                    
                    return false;
                });
            } else {
                // Just "Prague" with no district, keep as is
                results = results.filter(p => {
                    return (p.city && p.city.toLowerCase().includes('prague')) || 
                          (p.location && p.location.toLowerCase().includes('prague'));
                });
            }
        } else {
            const locationKeywords = criteria.location.toLowerCase().split(/\s+/);
            results = results.filter(p => {
                const propertyLocation = (p.location || "").toLowerCase();
                const propertyCity = (p.city || "").toLowerCase();
                const propertyDistrict = (p.district || "").toLowerCase();
                
                return locationKeywords.some(keyword => 
                    propertyLocation.includes(keyword) || 
                    propertyCity.includes(keyword) || 
                    propertyDistrict.includes(keyword)
                );
            });
        }
    }
        
        // Apply more relaxed size constraints (40% instead of 20%)
        if (criteria.size) {
            const targetSize = parseInt(criteria.size);
            if (!isNaN(targetSize)) {
                const minSize = targetSize * 0.6;
                const maxSize = targetSize * 1.4;
                
                results = results.filter(p => {
                    const propertySize = parseInt(p.size);
                    return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                });
            }
        } 
        // Relax min/max ranges
        else {
            if (criteria.maxSize) {
                const maxSize = parseInt(criteria.maxSize) * 1.2; // 20% higher than requested max
                if (!isNaN(maxSize)) {
                    results = results.filter(p => {
                        const propertySize = parseInt(p.size);
                        return !isNaN(propertySize) && propertySize <= maxSize;
                    });
                }
            }
            
            if (criteria.minSize) {
                const minSize = parseInt(criteria.minSize) * 0.8; // 20% lower than requested min
                if (!isNaN(minSize)) {
                    results = results.filter(p => {
                        const propertySize = parseInt(p.size);
                        return !isNaN(propertySize) && propertySize >= minSize;
                    });
                }
            }
        }
        
        debugLog(`After relaxed criteria with preserved district filter: ${results.length} properties remaining (was ${originalResultsCount})`);
    }
    
    debugLog(`Final search results: ${results.length} properties`);
    return results;
}

// Helper function to generate property listing HTML
function generatePropertyListingHTML(properties, offset = 0, limit = 5) {
    let html = "";
    
    // Get the relevant slice for pagination
    const propertiesToShow = properties.slice(offset, offset + limit);
    
    // Format property items
    propertiesToShow.forEach(property => {
        let propertyDetails = `<div class="property-item">
            <div class="property-name">${property.name}</div>`;
        
        propertyDetails += `<div class="property-details">`;
        
        if (property.size) {
            propertyDetails += `<span class="property-detail">${property.size} sqm</span>`;
        }
        
        if (property.type) {
            propertyDetails += `<span class="property-detail">${property.type}</span>`;
        }
        
        if (property.price) {
            propertyDetails += `<span class="property-detail">${property.price}</span>`;
        }
        
        if (property.floor) {
            propertyDetails += `<span class="property-detail">${property.floor}</span>`;
        }
        
        // Use location if available, otherwise fallback to city and district
        if (property.location) {
            propertyDetails += `<span class="property-detail">${property.location}</span>`;
        } else if (property.city) {
            let locationText = property.city;
            if (property.district) {
                locationText += ` - ${property.district}`;
            }
            propertyDetails += `<span class="property-detail">${locationText}</span>`;
        }
        
        if (property.available) {
            propertyDetails += `<span class="property-detail">Available: ${property.available}</span>`;
        }
        
        propertyDetails += `</div></div>`;
        
        html += propertyDetails;
    });
    
    return html;
}
 // Updated local response generator with improved criteria handling
function generateLocalResponse(userInput) {
    debugLog("Generating local response for:", userInput);
    userInput = userInput.toLowerCase();
    
    // Store for future reference
    conversationState.lastQuery = userInput;
    
    // Check if properties are loaded
    if (!propertiesLoaded || properties.length === 0) {
        debugLog("Properties not loaded, returning error message");
        return "I don't have access to our property listings at the moment. Please try again later or contact Integis directly for assistance.";
    }
    
    // Determine language for response (simple heuristic)
    const isCzechQuery = isCzech(userInput);
    debugLog("Language detection - isCzech:", isCzechQuery);
    
    // Check if this is a follow-up question
    const isFollowUp = isFollowUpQuestion(userInput);
    debugLog("Is follow-up question:", isFollowUp);
    
    // Create search criteria
    let criteria = {};
    
    // If follow-up, start with previous criteria
    if (isFollowUp && conversationState.currentSearchCriteria) {
        criteria = {...conversationState.currentSearchCriteria};
        debugLog("Using previous search criteria as base:", criteria);
        
        // For pagination requests, keep the same criteria but update offset
        if (/more|další|show more|ukázat více/i.test(userInput)) {
            conversationState.offset += 5; // Show next 5 results
            debugLog("Pagination request - updating offset to:", conversationState.offset);
        }
    } else {
        // Reset offset for new searches
        conversationState.offset = 0;
    }
    
    // Extract new criteria
    const newCriteria = extractSearchCriteria(userInput);
    
    // Merge with existing criteria, with new values taking precedence
    criteria = {...criteria, ...newCriteria};
    
    // For requests to "show all" - start fresh with just the core criteria
    if (/show all|share all|all properties|all units|všechny|všechny jednotky/i.test(userInput)) {
        // Keep only the most important criteria (type, location, size) and reset pagination
        const coreCriteria = {};
        if (criteria.type) coreCriteria.type = criteria.type;
        if (criteria.location) coreCriteria.location = criteria.location;
        if (criteria.size) coreCriteria.size = criteria.size;
        if (criteria.maxSize) coreCriteria.maxSize = criteria.maxSize;
        if (criteria.minSize) coreCriteria.minSize = criteria.minSize;
        
        criteria = coreCriteria;
        conversationState.offset = 0;
        debugLog("'Show all' request - using core criteria only:", criteria);
    }
    
    // IMPORTANT: Update the global conversation state with the new criteria
    conversationState.currentSearchCriteria = {...criteria};
    debugLog("Updated conversation state with new criteria:", conversationState.currentSearchCriteria);
    
    // Search for matching properties with enhanced search function
    let matchedProperties = enhancedSearchProperties(criteria);
    
    // Store the properties we've shown for follow-up questions
    if (matchedProperties.length > 0) {
        const propertiesToShow = matchedProperties.slice(
            conversationState.offset, 
            conversationState.offset + 5
        );
        
        // Update last shown properties
        conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
        debugLog("Updated last shown properties:", conversationState.lastShownProperties);
    }
    
    // Generate response
    if (matchedProperties.length > 0) {
        debugLog(`Generating response with ${matchedProperties.length} matching properties (offset: ${conversationState.offset})`);
        
        let response = "";
        
        if (isFollowUp && /more|další|show more|ukázat více/i.test(userInput) && conversationState.offset > 0) {
            response = isCzechQuery 
                ? `Ano, zde jsou další nemovitosti, které splňují vaše kritéria:<br><br>`
                : `Yes, here are more properties that match your criteria:<br><br>`;
        } else if (isFollowUp) {
            if (criteria.location && criteria.type) {
                if (criteria.minSize && criteria.maxSize) {
                    response = isCzechQuery 
                        ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location} o velikosti mezi ${criteria.minSize} a ${criteria.maxSize} m²:<br><br>`
                        : `I found these ${criteria.type} spaces in ${criteria.location} with a size between ${criteria.minSize} and ${criteria.maxSize} sqm:<br><br>`;
                } else if (criteria.size) {
                    response = isCzechQuery 
                        ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location} o velikosti kolem ${criteria.size} m²:<br><br>`
                        : `I found these ${criteria.type} spaces in ${criteria.location} with a size around ${criteria.size} sqm:<br><br>`;
                } else {
                    response = isCzechQuery 
                        ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location}:<br><br>`
                        : `I found these ${criteria.type} spaces in ${criteria.location}:<br><br>`;
                }
            } else {
                response = isCzechQuery 
                    ? `Na základě upřesněných kritérií jsem našel tyto nemovitosti:<br><br>`
                    : `Based on your refined criteria, I found these properties:<br><br>`;
            }
        } else {
            response = isCzechQuery 
                ? `Na základě vašeho dotazu jsem našel tyto nemovitosti, které by vás mohly zajímat:<br><br>`
                : `Based on your query, I found these properties that might interest you:<br><br>`;
        }
        
        // Get the relevant slice for pagination
        const propertiesToShow = matchedProperties.slice(
            conversationState.offset, 
            conversationState.offset + 5
        );
        
        // If no properties to show at current offset but we have matches
        if (propertiesToShow.length === 0 && matchedProperties.length > 0) {
            // Reset offset to 0 and show the first page
            conversationState.offset = 0;
            
            response = isCzechQuery 
                ? `Došli jsme na konec výsledků. Zde jsou znovu první nemovitosti:<br><br>`
                : `We've reached the end of the results. Here are the first properties again:<br><br>`;
                
            // Update properties to show
            const firstPageProperties = matchedProperties.slice(0, 5);
            conversationState.lastShownProperties = firstPageProperties.map(p => p.name);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, 0, 5);
        } else {
            // Add property listings HTML
            response += generatePropertyListingHTML(matchedProperties, conversationState.offset, 5);
        }
        
        // Add pagination (now with a button instead of text)
        const remainingCount = matchedProperties.length - (conversationState.offset + propertiesToShow.length);
        if (remainingCount > 0) {
            response += isCzechQuery
                ? `<br>Zobrazuji ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.<br>`
                : `<br>Showing ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} of ${matchedProperties.length} matching properties.<br>`;
            
            // Add "Show More" button
            response += `<div class="action-button-container">
                <button class="action-button" onclick="handleShowMore()">${isCzechQuery ? 'Zobrazit další' : 'Show More'}</button>
            </div>`;
        } else {
            response += isCzechQuery
                ? `<br>Zobrazuji ${propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.`
                : `<br>Showing ${propertiesToShow.length} of ${matchedProperties.length} matching properties.`;
        }
        
        // Add active filters
        response += generateActiveFiltersHTML(criteria, isCzechQuery);
        
        // Add refinement buttons
        response += generateRefinementButtonsHTML(criteria, isCzechQuery);
        
        
        return response;
    } else {
        debugLog("No matching properties found");
        
        let noMatchResponse = "";
        
        if (isFollowUp) {
            noMatchResponse = isCzechQuery
                ? `Bohužel jsem nenašel žádné nemovitosti, které by odpovídaly těmto upřesněným požadavkům. Možná zkuste jiné parametry?`
                : `I couldn't find any properties matching these refined criteria. Perhaps try different parameters?`;
                
            // Suggest alternatives by relaxing constraints
            if (criteria.location && criteria.type) {
                // Try without size constraint
                const withoutSizeSearch = {...criteria};
                delete withoutSizeSearch.size;
                delete withoutSizeSearch.maxSize;
                delete withoutSizeSearch.minSize;
                
                const sizeAlternatives = enhancedSearchProperties(withoutSizeSearch);
                
                if (sizeAlternatives.length > 0) {
                    noMatchResponse += isCzechQuery
                        ? `<br><br>Našel jsem však ${sizeAlternatives.length} ${criteria.type} nemovitostí v lokalitě ${criteria.location} bez omezení velikosti. Přejete si je zobrazit?`
                        : `<br><br>However, I found ${sizeAlternatives.length} ${criteria.type} properties in ${criteria.location} without size restrictions. Would you like to see them?`;
                }
            }
        } else {
            noMatchResponse = isCzechQuery
                ? `Bohužel jsem nenašel přesné shody pro vaše kritéria z našich ${properties.length} nemovitostí. Můžete zkusit obecnější vyhledávání? Například se můžete zeptat na "kancelářské prostory v Praze" nebo "obchodní prostory kolem 800 sqm".`
                : `I couldn't find exact matches for your criteria from our ${properties.length} properties. Could you try a more general search? For example, you can ask about "office space in Prague" or "retail space around 800 sqm".`;
        }
        
        return noMatchResponse;
    }
}

// Enhanced function to call Gemini API specifically for people to sqm conversion
async function callGeminiAPIForPeopleConversion(peopleCount, spaceType = "office") {
    debugLog("Calling Gemini API to convert people count to sqm");
    
    try {
        // Format the prompt for Gemini
        const conversionPrompt = `
        You are a commercial real estate expert. Convert number of people to square meters needed for ${spaceType} space.
        Be realistic and follow these guidelines:
        - For office space: typically 8-12 sqm per person for standard offices, 15-20 sqm for executive space
        - For retail: depends on type but generally 15-40 sqm per staff member
        - For industrial: typically 25-50 sqm per worker depending on operations
        
        For ${peopleCount} people in a ${spaceType} space, provide:
        1. The minimum and maximum sqm required as a range
        2. A short explanation about why this amount of space is appropriate
        3. Additional considerations like meeting rooms, common areas, etc.
        
        Format your response EXACTLY as a JSON object with these properties:
        {
          "minSize": number,
          "maxSize": number,
          "explanation": "brief explanation text",
          "considerations": "brief additional considerations"
        }
        
        Do not include any other text, ONLY return the JSON object.
        `;
        
        // Call the Gemini API
        const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: [
                    {
                        role: "user",
                        parts: [{ text: conversionPrompt }]
                    }
                ],
                generationConfig: {
                    temperature: 0.2,  // Lower temperature for more deterministic output
                    maxOutputTokens: 400
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const result = await response.json();
        
        // Extract the generated text
        if (result.candidates && result.candidates.length > 0 && 
            result.candidates[0].content && result.candidates[0].content.parts && 
            result.candidates[0].content.parts.length > 0) {
            
            const generatedText = result.candidates[0].content.parts[0].text.trim();
            debugLog("Received conversion response:", generatedText);
            
            // Parse the JSON response
            try {
                const conversion = JSON.parse(generatedText);
                if (conversion.minSize && conversion.maxSize) {
                    return {
                        minSize: Math.round(conversion.minSize),
                        maxSize: Math.round(conversion.maxSize),
                        explanation: conversion.explanation || "This size range is appropriate based on commercial real estate standards.",
                        considerations: conversion.considerations || "Consider meeting rooms, break areas, and circulation space."
                    };
                }
            } catch (parseError) {
                debugLog("Error parsing conversion JSON:", parseError.message);
                // Try to extract numbers from the text if JSON parsing fails
                const numbers = generatedText.match(/\d+/g);
                if (numbers && numbers.length >= 2) {
                    return {
                        minSize: Math.round(parseInt(numbers[0])),
                        maxSize: Math.round(parseInt(numbers[1])),
                        explanation: "This size range is based on industry standards.",
                        considerations: "Consider additional space for amenities and common areas."
                    };
                }
            }
        }
        
        throw new Error("Could not extract size conversion from Gemini response");
    } catch (error) {
        debugLog("Error in people to sqm conversion:", error.message);
        // Provide a fallback conversion based on standard metrics
        const fallbackSizes = {
            "office": { min: Math.round(peopleCount * 8), max: Math.round(peopleCount * 12) },
            "retail": { min: Math.round(peopleCount * 15), max: Math.round(peopleCount * 40) },
            "industrial": { min: Math.round(peopleCount * 25), max: Math.round(peopleCount * 50) }
        };
        
        const fallback = fallbackSizes[spaceType] || fallbackSizes.office;
        debugLog("Using fallback conversion:", fallback);
        
        return {
            minSize: fallback.min,
            maxSize: fallback.max,
            explanation: `Based on industry standards, we typically allocate ${fallback.min/peopleCount}-${fallback.max/peopleCount} sqm per person for ${spaceType} space.`,
            considerations: `For ${peopleCount} people, consider additional space for meeting rooms, reception areas, and circulation space.`
        };
    }
}
 // Call the Gemini API
async function callGeminiAPI(userInput) {
    debugLog("Starting Gemini API call for input:", userInput);
    
    // Check if properties are loaded
    if (!propertiesLoaded || properties.length === 0) {
        debugLog("Properties not loaded, returning error message");
        return "I don't have access to our property listings at the moment. Please try again later or ask general questions about commercial real estate.";
    }
    
    // Format properties as text for the prompt (limited to keep size manageable)
    let propertiesText = "";
    properties.slice(0, 20).forEach(property => { // Reduced to 20 properties
        let detailsText = `- ${property.name}: ${property.size} sqm ${property.type || ""}`;
        
        if (property.price) {
            detailsText += `, ${property.price}`;
        }
        
        if (property.location) {
            detailsText += ` in ${property.location}`;
        } else if (property.city) {
            detailsText += ` in ${property.city}`;
            if (property.district) {
                detailsText += ` - ${property.district}`;
            }
        }
        
        if (property.available) {
            detailsText += `, available: ${property.available}`;
        }
        
        detailsText += "\n";
        propertiesText += detailsText;
    });

    // Previous conversation messages for context
    const previousMessages = [];
    for (let i = 0; i < conversationHistory.length; i++) {
        const message = conversationHistory[i];
        previousMessages.push({
            role: message.role,
            parts: [{ text: message.content }]
        });
    }

    // Create the system prompt
    const systemPrompt = `You are a professional commercial real estate assistant for Integis. Your job is to help clients find the perfect office, retail, or industrial space based on their needs. Be concise, professional, and helpful.

IMPORTANT INSTRUCTIONS:
1. ALWAYS maintain conversation context throughout the entire chat session
2. Remember previous searches and parameters
3. When user asks follow-up questions, add to their previous search criteria instead of replacing it
4. If they ask for "offices in Ostrava under 100 sqm" and then later ask "what about in Prague?", keep the type (office) and size (under 100 sqm) but change the location
5. When presenting properties, format them in an easy-to-read way with HTML (use <div>, <span> tags with appropriate classes)
6. If you don't have information, be honest and offer to help in other ways
7. Always respond in the same language as the user (Czech or English)

CONVERSATION CONTEXT:
Current Search Criteria: ${JSON.stringify(conversationState.currentSearchCriteria || {})}
Last Shown Properties: ${JSON.stringify(conversationState.lastShownProperties || [])}

AVAILABLE PROPERTIES:
${propertiesText}`;

    try {
        // Format the request for Gemini API
        const requestData = {
            contents: [
                {
                    role: "user",
                    parts: [{ text: systemPrompt }]
                },
                {
                    role: "model",
                    parts: [{ text: "I understand. I am a professional commercial real estate assistant for Integis. I'll help clients find properties based on their needs while maintaining conversation context and following all your instructions." }]
                },
                {
                    role: "user",
                    parts: [{ text: userInput }]
                }
            ],
            generationConfig: {
                temperature: 0.7,
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 800,
            }
        };

        // Add previous conversation messages if available
        if (previousMessages.length > 1) { // Skip welcome message
            requestData.contents = [
                {
                    role: "user",
                    parts: [{ text: systemPrompt }]
                },
                {
                    role: "model",
                    parts: [{ text: "I understand. I am a professional commercial real estate assistant for Integis. I'll help clients find properties based on their needs while maintaining conversation context and following all your instructions." }]
                },
                ...previousMessages.slice(1), // Add all previous messages except welcome
                {
                    role: "user",
                    parts: [{ text: userInput }]
                }
            ];
        }

        // Call the Gemini API
        debugLog("Sending API request to Gemini API");
        const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        });

        debugLog("Gemini API Response Status:", response.status);

        if (!response.ok) {
            const errorText = await response.text();
            debugLog("Gemini API Error:", errorText);
            throw new Error(`API error: ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        debugLog("Gemini API result structure:", Object.keys(result));

        // Extract the generated text
        if (result && result.candidates && result.candidates.length > 0 && 
            result.candidates[0].content && result.candidates[0].content.parts && 
            result.candidates[0].content.parts.length > 0) {
            
            const generatedText = result.candidates[0].content.parts[0].text;
            debugLog("Successfully received generated text (first 100 chars):", generatedText.substring(0, 100) + "...");
            return generatedText;
        } else {
            debugLog("Unexpected API response format:", result);
            return "I received an unexpected response format. Please try again.";
        }
    } catch (error) {
        debugLog("Error calling Gemini API:", error.message);
        
        if (error.message.includes("Failed to fetch") || error.message.includes("NetworkError")) {
            return "I'm having trouble connecting to my language model service. This might be due to network issues or service availability. Please try again later.";
        }
        
        return "I encountered an error while trying to answer your question. Please try again.";
    }
}

// Improved sendMessage function
async function sendMessage() {
    const userInput = document.getElementById('user-input');
    const inputText = userInput.value.trim();
    
    // First check for command - this should be the first thing we do
    if (inputText.toLowerCase() === "!test api") {
        userInput.value = '';
        testGeminiAPI();
        return;
    }
    
    if (!inputText) return;
    
    debugLog("User input:", inputText);
    
    // Save to conversation state before clearing
    conversationState.lastQuery = inputText;
    
    // Add user message
    addMessage(inputText, 'user');
    
    // Add to conversation history
    conversationHistory.push({role: "user", content: inputText});
    debugLog("Updated conversation history:", conversationHistory.length + " messages");
    
    // Clear input
    userInput.value = '';
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
    
    // Ensure properties are loaded
    if (!propertiesLoaded) {
        debugLog("Properties not loaded, loading now...");
        await loadProperties();
    }

    // Extract criteria to check for people-based query
    const criteria = extractSearchCriteria(inputText);
    
    // Check for specific "help me with size" query without a number
    const isHelpWithSizeQuery = /help me with size|size help|help with sizing|pomoc s velikostí|pomoc s prostorem/i.test(inputText) && !criteria.peopleCount;
    
    if (isHelpWithSizeQuery) {
        // User asked for help with sizing but didn't specify a number of people
        const helpMessage = isCzech(inputText)
            ? "Rád vám pomůžu určit správnou velikost prostoru. Kolik lidí bude prostor využívat?"
            : "I'd be happy to help you determine the right space size. How many people will be using the space?";
        
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Add message with size range buttons
        const sizeRanges = [
            { range: '0-10', labelCz: '0-10 lidí', labelEn: '0-10 people' },
            { range: '11-20', labelCz: '11-20 lidí', labelEn: '11-20 people' },
            { range: '21-50', labelCz: '21-50 lidí', labelEn: '21-50 people' },
            { range: '51-100', labelCz: '51-100 lidí', labelEn: '51-100 people' },
            { range: '100+', labelCz: 'Více než 100 lidí', labelEn: 'More than 100 people' }
        ];
        
        let sizeRangeButtonsHTML = `<div class="suggestion-buttons">`;
        sizeRanges.forEach(sizeRange => {
            const label = isCzech(inputText) ? sizeRange.labelCz : sizeRange.labelEn;
            let peopleCount;
            
            if (sizeRange.range === '0-10') {
                peopleCount = 10; // Use the upper bound
            } else if (sizeRange.range === '11-20') {
                peopleCount = 20; // Use the upper bound
            } else if (sizeRange.range === '21-50') {
                peopleCount = 50; // Use the upper bound
            } else if (sizeRange.range === '51-100') {
                peopleCount = 100; // Use the upper bound
            } else if (sizeRange.range === '100+') {
                peopleCount = 150; // Use a reasonable value for 100+
            }
            
            sizeRangeButtonsHTML += `<button class="suggestion-button" onclick="handlePeopleCountClick(${peopleCount}, '${label}')">
                ${label}
            </button>`;
        });
        sizeRangeButtonsHTML += `</div>`;
        
        addMessage(helpMessage + "<br><br>" + sizeRangeButtonsHTML, 'bot');
        conversationHistory.push({role: "assistant", content: helpMessage});
        return;
    }
    
    // If this is a people-based query, use Gemini to convert people to sqm
    if (criteria.peopleCount) {
        try {
            debugLog("People-based query detected, using Gemini to convert to sqm");
            
            // Call Gemini API to convert people to sqm
            const conversionResponse = await callGeminiAPIForPeopleConversion(criteria.peopleCount, criteria.type || "office");
            
            // Update criteria with the sqm conversion
            if (conversionResponse.minSize && conversionResponse.maxSize) {
                debugLog(`Converted ${criteria.peopleCount} people to ${conversionResponse.minSize}-${conversionResponse.maxSize} sqm`);
                
                // Update criteria with the size range
                delete criteria.size; // Remove any size if present
                criteria.minSize = conversionResponse.minSize;
                criteria.maxSize = conversionResponse.maxSize;
                
                // Remove the peopleCount flag
                delete criteria.peopleCount;
                
                // Update conversation state
                conversationState.currentSearchCriteria = {...criteria};
                
                // Search with the updated criteria
                const matchedProperties = enhancedSearchProperties(criteria);
                
                if (matchedProperties.length > 0) {
                    // Format the explanation with the details from Gemini
                    const conversionExplanation = isCzech(inputText)
                        ? `Pro ${criteria.peopleCount} osob byste potřebovali přibližně ${criteria.minSize}-${criteria.maxSize} m². ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Zde jsou nemovitosti, které odpovídají těmto požadavkům:`
                        : `For ${criteria.peopleCount} people, you would need approximately ${criteria.minSize}-${criteria.maxSize} sqm. ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Here are the properties that match these requirements:`;
                    
                    // Generate property listings HTML
                    const propertyListingsHTML = generatePropertyListingHTML(matchedProperties, conversationState.offset, 5);
                    
                    // Add pagination information
                    const paginationHTML = isCzech(inputText)
                        ? `<br>Zobrazuji 1-${Math.min(5, matchedProperties.length)} z ${matchedProperties.length} nalezených nemovitostí.${matchedProperties.length > 5 ? '<br><div class="action-button-container"><button class="action-button" onclick="handleShowMore()">Zobrazit další</button></div>' : ''}`
                        : `<br>Showing 1-${Math.min(5, matchedProperties.length)} of ${matchedProperties.length} matching properties.${matchedProperties.length > 5 ? '<br><div class="action-button-container"><button class="action-button" onclick="handleShowMore()">Show More</button></div>' : ''}`;
                    
                    // Add active filters
                    const filtersHTML = generateActiveFiltersHTML(criteria, isCzech(inputText));
                    
                    // Add refinement buttons
                    const refinementHTML = generateRefinementButtonsHTML(criteria, isCzech(inputText));
                    
                    // Add suggestion buttons
                    const suggestionHTML = generateSuggestionButtonsHTML(criteria, isCzech(inputText));
                    
                    // Combine everything
                    const fullResponse = conversionExplanation + "<br><br>" + propertyListingsHTML + paginationHTML + filtersHTML + refinementHTML + suggestionHTML;
                    
                    // Display the response
                    if (document.getElementById('typing-indicator')) {
                        document.getElementById('typing-indicator').remove();
                    }
                    
                    // Update last shown properties
                    conversationState.lastShownProperties = matchedProperties.slice(0, 5).map(p => p.name);
                    
                    addMessage(fullResponse, 'bot');
                    conversationHistory.push({role: "assistant", content: fullResponse});
                    return;
                } else {
                    // No matching properties found
                    const noMatchResponse = isCzech(inputText)
                        ? `Pro ${criteria.peopleCount} osob byste potřebovali přibližně ${criteria.minSize}-${criteria.maxSize} m². ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Bohužel jsem nenašel žádné nemovitosti, které přesně odpovídají těmto parametrům. Zkuste prosím upravit kritéria vyhledávání nebo se podívat na alternativy.`
                        : `For ${criteria.peopleCount} people, you would need approximately ${criteria.minSize}-${criteria.maxSize} sqm. ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Unfortunately, I couldn't find any properties that exactly match these parameters. Please try adjusting your search criteria or looking at alternatives.`;
                    
                    if (document.getElementById('typing-indicator')) {
                        document.getElementById('typing-indicator').remove();
                    }
                    
                    addMessage(noMatchResponse, 'bot');
                    conversationHistory.push({role: "assistant", content: noMatchResponse});
                    return;
                }
            }
        } catch (error) {
            debugLog("Error processing people-based query:", error.message);
            // Continue with normal flow if there's an error
        }
    }

    // STRATEGY: First generate a local response that we can fall back to
    const fallbackResponse = generateLocalResponse(inputText);
    debugLog("Generated fallback response");
    
    // If our fallback found property matches, prioritize it for instant response
    const containsPropertyItems = fallbackResponse.includes("property-item");
    
    if (containsPropertyItems) {
        debugLog("Fallback contains property matches, using it immediately");
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Save this response to conversation state
        conversationState.lastResponse = fallbackResponse;
        
        addMessage(fallbackResponse, 'bot');
        
        // Add to conversation history
        conversationHistory.push({role: "assistant", content: fallbackResponse});
        return;
    }
    
    // If fallback didn't find properties, try Gemini API
    try {
        debugLog("Attempting to use Gemini API");
        // Try to call Gemini API with timeout
        const apiPromise = callGeminiAPI(inputText);
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => {
                debugLog("API call timed out after 20 seconds");
                reject(new Error("API call timed out"))
            }, 20000)
        );
        
        const aiResponse = await Promise.race([apiPromise, timeoutPromise]);
        debugLog("Received API response");
        
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Save this response to conversation state
        conversationState.lastResponse = aiResponse;
        
        addMessage(aiResponse, 'bot');
        
        // Add to conversation history
        conversationHistory.push({role: "assistant", content: aiResponse});
    } catch (error) {
        // Use the fallback response we already generated
        debugLog("Error calling AI, using fallback:", error.message);
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Save this response to conversation state
        conversationState.lastResponse = fallbackResponse;
        
        addMessage(fallbackResponse, 'bot');
        
        // Add to conversation history
        conversationHistory.push({role: "assistant", content: fallbackResponse});
    }
}
// Function to add a message to the chat
function addMessage(text, sender) {
    const messagesDiv = document.getElementById('messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    messageDiv.innerHTML = text;
    
    // Clear any previous messages with the same float direction
    const clearDiv = document.createElement('div');
    clearDiv.className = 'clearfix';
    messagesDiv.appendChild(clearDiv);
    
    messagesDiv.appendChild(messageDiv);
    
    // Another clearfix after the message
    const clearDiv2 = document.createElement('div');
    clearDiv2.className = 'clearfix';
    messagesDiv.appendChild(clearDiv2);
    
    // Scroll to bottom
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    
    return messageDiv;
}

// Special debugging function for API testing
function testGeminiAPI() {
    // Important: Don't add to conversation history
    debugLog("Testing Gemini API connection as a special command");
    
    // Clear any existing typing indicators
    if (document.getElementById('typing-indicator')) {
        document.getElementById('typing-indicator').remove();
    }
    
    // Add a message to the chat about the test
    const testMessage = addMessage("Testing Gemini API connection...", 'bot');
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Testing API...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Try a simple call to the Gemini model
    fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            contents: [
                {
                    role: "user",
                    parts: [{ text: "Hello, this is a test." }]
                }
            ],
            generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 100
            }
        })
    })
    .then(response => {
        debugLog("API test response status:", response.status);
        return response.text().then(text => {
            return { status: response.status, text: text };
        });
    })
    .then(({ status, text }) => {
        debugLog("API test response:", text);
        
        let testResult = "";
        
        try {
            if (status >= 200 && status < 300) {
                const jsonResponse = JSON.parse(text);
                testResult = "✅ Gemini API is accessible and responded successfully!";
                
                if (jsonResponse.candidates && jsonResponse.candidates.length > 0 && 
                    jsonResponse.candidates[0].content && jsonResponse.candidates[0].content.parts && 
                    jsonResponse.candidates[0].content.parts.length > 0) {
                    const modelResponse = jsonResponse.candidates[0].content.parts[0].text;
                    testResult += `<br><br>Model response: "${modelResponse.substring(0, 100)}${modelResponse.length > 100 ? '...' : ''}"`;
                }
            } else {
                if (text.includes("API key not valid")) {
                    testResult = "❌ Authentication failed. Your API key may be invalid or expired.";
                } else if (status === 403) {
                    testResult = "❌ Access denied to Gemini API (403). Check your API key permissions.";
                } else if (status === 404) {
                    testResult = "❌ Gemini API endpoint not found (404). The API URL may be incorrect.";
                } else {
                    testResult = `❌ Error accessing Gemini API: ${text}`;
                }
            }
        } catch (error) {
            testResult = `❌ Error parsing API response: ${error.message}<br><br>Raw response (status ${status}): ${text}`;
        }
        
        return testResult;
    })
    .then(finalResult => {
        // Remove typing indicator
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Display the test result
        addMessage(`<strong>Gemini API Test Results:</strong><br><br>${finalResult}`, 'bot');
    })
    .catch(error => {
        debugLog("API test error:", error);
        
        // Remove typing indicator
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Display error message
        addMessage(`<strong>API Test Failed:</strong><br><br>❌ ${error.message}`, 'bot');
    });
}

// Function to handle button clicks
function handleSuggestionClick(suggestion) {
    // Add the suggestion text to the input field
    document.getElementById('user-input').value = suggestion;
    
    // Submit the form (trigger sendMessage)
    sendMessage();
}

// Function to handle "Help me with size" button click
function handleSizeHelpClick() {
    // User asked for help with sizing
    const isCzechQuery = isCzech(document.getElementById('user-input').value);
    const helpMessage = isCzechQuery
        ? "Rád vám pomůžu určit správnou velikost prostoru. Kolik lidí bude prostor využívat?"
        : "I'd be happy to help you determine the right space size. How many people will be using the space?";
    
    // Add the "Help me with size" message to the chat as if the user had asked it
    addMessage(isCzechQuery ? "Pomoc s výběrem velikosti" : "Help me with size", 'user');
    conversationHistory.push({role: "user", content: isCzechQuery ? "Pomoc s výběrem velikosti" : "Help me with size"});
    
    // Add size range buttons
    const sizeRanges = [
        { range: '0-10', labelCz: '0-10 lidí', labelEn: '0-10 people' },
        { range: '11-20', labelCz: '11-20 lidí', labelEn: '11-20 people' },
        { range: '21-50', labelCz: '21-50 lidí', labelEn: '21-50 people' },
        { range: '51-100', labelCz: '51-100 lidí', labelEn: '51-100 people' },
        { range: '100+', labelCz: 'Více než 100 lidí', labelEn: 'More than 100 people' }
    ];
    
    let sizeRangeButtonsHTML = `<div class="suggestion-buttons">`;
    sizeRanges.forEach(sizeRange => {
        const label = isCzechQuery ? sizeRange.labelCz : sizeRange.labelEn;
        let peopleCount;
        
        if (sizeRange.range === '0-10') {
            peopleCount = 10; // Use the upper bound
        } else if (sizeRange.range === '11-20') {
            peopleCount = 20; // Use the upper bound
        } else if (sizeRange.range === '21-50') {
            peopleCount = 50; // Use the upper bound
        } else if (sizeRange.range === '51-100') {
            peopleCount = 100; // Use the upper bound
        } else if (sizeRange.range === '100+') {
            peopleCount = 150; // Use a reasonable value for 100+
        }
        
        sizeRangeButtonsHTML += `<button class="suggestion-button" onclick="handlePeopleCountClick(${peopleCount}, '${label}')">
            ${label}
        </button>`;
    });
    sizeRangeButtonsHTML += `</div>`;
    
    // Display the help message with size range buttons
    addMessage(helpMessage + "<br><br>" + sizeRangeButtonsHTML, 'bot');
    conversationHistory.push({role: "assistant", content: helpMessage});
}
     function handleSizeHelpClickFromRefinement() {
    debugLog("handleSizeHelpClickFromRefinement called"); // Add this debug line
    // User asked for help with sizing
    const isCzechQuery = isCzech(document.getElementById('user-input').value);
    const helpMessage = isCzechQuery
        ? "Rád vám pomůžu určit správnou velikost prostoru. Kolik lidí bude prostor využívat?"
        : "I'd be happy to help you determine the right space size. How many people will be using the space?";
    
    // Add the "Help me with size" message to the chat as if the user had asked it
    addMessage(isCzechQuery ? "Pomoc s výběrem velikosti" : "Help me with size", 'user');
    conversationHistory.push({role: "user", content: isCzechQuery ? "Pomoc s výběrem velikosti" : "Help me with size"});
    
    // Add size range buttons
    const sizeRanges = [
        { range: '0-10', labelCz: '0-10 lidí', labelEn: '0-10 people' },
        { range: '11-20', labelCz: '11-20 lidí', labelEn: '11-20 people' },
        { range: '21-50', labelCz: '21-50 lidí', labelEn: '21-50 people' },
        { range: '51-100', labelCz: '51-100 lidí', labelEn: '51-100 people' },
        { range: '100+', labelCz: 'Více než 100 lidí', labelEn: 'More than 100 people' }
    ];
    
    let sizeRangeButtonsHTML = `<div class="suggestion-buttons">`;
    sizeRanges.forEach(sizeRange => {
        const label = isCzechQuery ? sizeRange.labelCz : sizeRange.labelEn;
        let peopleCount;
        
        if (sizeRange.range === '0-10') {
            peopleCount = 10; // Use the upper bound
        } else if (sizeRange.range === '11-20') {
            peopleCount = 20; // Use the upper bound
        } else if (sizeRange.range === '21-50') {
            peopleCount = 50; // Use the upper bound
        } else if (sizeRange.range === '51-100') {
            peopleCount = 100; // Use the upper bound
        } else if (sizeRange.range === '100+') {
            peopleCount = 150; // Use a reasonable value for 100+
        }
        
        sizeRangeButtonsHTML += `<button class="suggestion-button" onclick="handlePeopleCountClick(${peopleCount}, '${label}')">
            ${label}
        </button>`;
    });
    sizeRangeButtonsHTML += `</div>`;
    
    // Display the help message with size range buttons
    addMessage(helpMessage + "<br><br>" + sizeRangeButtonsHTML, 'bot');
    conversationHistory.push({role: "assistant", content: helpMessage});
}
     
// Function to handle people count button click
function handlePeopleCountClick(peopleCount, displayText) {
    // Add the user's selection to the chat
    addMessage(displayText, 'user');
    conversationHistory.push({role: "user", content: displayText});
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Process the people count
    setTimeout(async () => {
        try {
            // Set default type to office if not specified
            const currentCriteria = conversationState.currentSearchCriteria || {};
            const spaceType = currentCriteria.type || "office";
            
            // Call Gemini API to convert people to sqm
            const conversionResponse = await callGeminiAPIForPeopleConversion(peopleCount, spaceType);
            
            // Create criteria with the size range
            const criteria = {...currentCriteria};
            delete criteria.size; // Remove any size if present
            criteria.minSize = conversionResponse.minSize;
            criteria.maxSize = conversionResponse.maxSize;
            
            // Update conversation state
            conversationState.currentSearchCriteria = criteria;
            
            // Search with the updated criteria
            const matchedProperties = enhancedSearchProperties(criteria);
            
            // Remove typing indicator
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            if (matchedProperties.length > 0) {
                // Format the explanation with the details from Gemini
                const isCzechQuery = isCzech(displayText);
                const conversionExplanation = isCzechQuery
                    ? `Pro ${peopleCount} osob byste potřebovali přibližně ${criteria.minSize}-${criteria.maxSize} m². ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Zde jsou nemovitosti, které odpovídají těmto požadavkům:`
                    : `For ${peopleCount} people, you would need approximately ${criteria.minSize}-${criteria.maxSize} sqm. ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Here are the properties that match these requirements:`;
                
                // Generate property listings HTML
                const propertyListingsHTML = generatePropertyListingHTML(matchedProperties, 0, 5);
                
                // Add pagination information
                const paginationHTML = isCzechQuery
                    ? `<br>Zobrazuji 1-${Math.min(5, matchedProperties.length)} z ${matchedProperties.length} nalezených nemovitostí.${matchedProperties.length > 5 ? '<br><div class="action-button-container"><button class="action-button" onclick="handleShowMore()">Zobrazit další</button></div>' : ''}`
                    : `<br>Showing 1-${Math.min(5, matchedProperties.length)} of ${matchedProperties.length} matching properties.${matchedProperties.length > 5 ? '<br><div class="action-button-container"><button class="action-button" onclick="handleShowMore()">Show More</button></div>' : ''}`;
                
                // Add active filters
                const filtersHTML = generateActiveFiltersHTML(criteria, isCzechQuery);
                
                // Add refinement buttons
                const refinementHTML = generateRefinementButtonsHTML(criteria, isCzechQuery);
                
                // Combine everything
                const fullResponse = conversionExplanation + "<br><br>" + propertyListingsHTML + paginationHTML + filtersHTML + refinementHTML;
                
                // Update last shown properties
                conversationState.lastShownProperties = matchedProperties.slice(0, 5).map(p => p.name);
                
                // Display the response
                addMessage(fullResponse, 'bot');
                conversationHistory.push({role: "assistant", content: fullResponse});
            } else {
                // No matching properties found
                const isCzechQuery = isCzech(displayText);
                const noMatchResponse = isCzechQuery
                    ? `Pro ${peopleCount} osob byste potřebovali přibližně ${criteria.minSize}-${criteria.maxSize} m². ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Bohužel jsem nenašel žádné nemovitosti, které přesně odpovídají těmto parametrům. Zkuste prosím upravit kritéria vyhledávání nebo se podívat na alternativy.`
                    : `For ${peopleCount} people, you would need approximately ${criteria.minSize}-${criteria.maxSize} sqm. ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}<br><br>Unfortunately, I couldn't find any properties that exactly match these parameters. Please try adjusting your search criteria or looking at alternatives.`;
                
                // Display the response
                addMessage(noMatchResponse, 'bot');
                conversationHistory.push({role: "assistant", content: noMatchResponse});
            }
        } catch (error) {
            debugLog("Error processing people count:", error.message);
            
            // Remove typing indicator
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            // Display error message
            const errorMessage = isCzech(displayText)
                ? "Omlouvám se, ale došlo k chybě při zpracování vašeho požadavku. Zkuste prosím zadat počet lidí přímo ve vašem dotazu, například: 'Potřebuji kancelář pro 50 lidí'."
                : "I'm sorry, but there was an error processing your request. Please try specifying the number of people directly in your query, for example: 'I need an office for 50 people'.";
            
            addMessage(errorMessage, 'bot');
            conversationHistory.push({role: "assistant", content: errorMessage});
        }
    }, 1000);
}     

// Function to handle people count button click
function handlePeopleCountClick(peopleCount, displayText) {
    // Function code...
}

// Function to handle "Help me with size" button click from guided search
function handleSizeHelpFromGuided(spaceType) {
    // Save the current guided search progress to global state for later use
    window.savedProgressiveFlow = {...conversationState.progressiveFlow};
    
    // Temporarily remove the flow to prevent conflicts
    delete conversationState.progressiveFlow;
    
    // User asked for help with sizing
    const isCzechQuery = isCzech(document.getElementById('user-input').value);
    const helpMessage = isCzechQuery
        ? "Rád vám pomůžu určit správnou velikost prostoru. Kolik lidí bude prostor využívat?"
        : "I'd be happy to help you determine the right space size. How many people will be using the space?";
    
    // Add the "Help me with size" message to the chat as if the user had asked it
    addMessage(isCzechQuery ? "Pomoc s výběrem velikosti" : "Help me with size", 'user');
    conversationHistory.push({role: "user", content: isCzechQuery ? "Pomoc s výběrem velikosti" : "Help me with size"});
    
    // Add size range buttons
    const sizeRanges = [
        { range: '0-10', labelCz: '0-10 lidí', labelEn: '0-10 people' },
        { range: '11-20', labelCz: '11-20 lidí', labelEn: '11-20 people' },
        { range: '21-50', labelCz: '21-50 lidí', labelEn: '21-50 people' },
        { range: '51-100', labelCz: '51-100 lidí', labelEn: '51-100 people' },
        { range: '100+', labelCz: 'Více než 100 lidí', labelEn: 'More than 100 people' }
    ];
    
    let sizeRangeButtonsHTML = `<div class="suggestion-buttons">`;
    sizeRanges.forEach(sizeRange => {
        const label = isCzechQuery ? sizeRange.labelCz : sizeRange.labelEn;
        let peopleCount;
        
        if (sizeRange.range === '0-10') {
            peopleCount = 10; // Use the upper bound
        } else if (sizeRange.range === '11-20') {
            peopleCount = 20; // Use the upper bound
        } else if (sizeRange.range === '21-50') {
            peopleCount = 50; // Use the upper bound
        } else if (sizeRange.range === '51-100') {
            peopleCount = 100; // Use the upper bound
        } else if (sizeRange.range === '100+') {
            peopleCount = 150; // Use a reasonable value for 100+
        }
        
        // Store the space type in a global variable for reference
        window.guidedSpaceType = spaceType;
        
        sizeRangeButtonsHTML += `<button class="suggestion-button" onclick="handlePeopleCountFromGuided(${peopleCount}, '${label}')">${label}</button>`;
    });
    sizeRangeButtonsHTML += `</div>`;
    
    // Display the help message with size range buttons
    addMessage(helpMessage + "<br><br>" + sizeRangeButtonsHTML, 'bot');
    conversationHistory.push({role: "assistant", content: helpMessage});
}

// Function to handle people count button click from guided search
function handlePeopleCountFromGuided(peopleCount, displayText) {
    // Get the saved flow from global state
    const savedFlow = window.savedProgressiveFlow;
    const spaceType = window.guidedSpaceType || 'office';
    
    if (!savedFlow) {
        debugLog("Error: No saved guided flow found");
        // Handle error case - go back to normal flow
        handlePeopleCountClick(peopleCount, displayText);
        return;
    }
    
    // Add the user's selection to the chat
    addMessage(displayText, 'user');
    conversationHistory.push({role: "user", content: displayText});
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Process the people count
    setTimeout(async () => {
        try {
            // Call Gemini API to convert people to sqm
            const conversionResponse = await callGeminiAPIForPeopleConversion(peopleCount, spaceType);
            
            // Get the size range 
            const minSize = conversionResponse.minSize;
            const maxSize = conversionResponse.maxSize;
            
            // Remove typing indicator
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            // Format the explanation with the details from Gemini
            const isCzechQuery = isCzech(displayText);
            const conversionExplanation = isCzechQuery
                ? `Pro ${peopleCount} osob byste potřebovali přibližně ${minSize}-${maxSize} m². ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}`
                : `For ${peopleCount} people, you would need approximately ${minSize}-${maxSize} sqm. ${conversionResponse.explanation}<br><br>${conversionResponse.considerations}`;
            
            // Display the explanation
            addMessage(conversionExplanation, 'bot');
            conversationHistory.push({role: "assistant", content: conversionExplanation});
            
            // Determine which size range option to use
            let sizeValue, sizeDisplay;
            
            if (maxSize <= 100) {
                sizeValue = 'up to 100';
                sizeDisplay = 'Up to 100 sqm';
            } else if (minSize >= 1000) {
                sizeValue = 'more than 1000';
                sizeDisplay = 'More than 1000 sqm';
            } else if (minSize >= 500) {
                sizeValue = '500-1000';
                sizeDisplay = '500-1000 sqm';
            } else if (minSize >= 300) {
                sizeValue = '300-500';
                sizeDisplay = '300-500 sqm';
            } else {
                sizeValue = '100-300';
                sizeDisplay = '100-300 sqm';
            }
            
            // Restore the guided flow with the new size
            savedFlow.answers.size = sizeValue;
            
            // Continue the guided flow from the size step
            savedFlow.currentStep = 2; // Set to the next step after size (availability)
            conversationState.progressiveFlow = savedFlow;
            
            // Clean up our global variables
            delete window.savedProgressiveFlow;
            delete window.guidedSpaceType;
            
            // Proceed with the next step in guided flow
            setTimeout(() => {
                handleProgressiveAnswer(sizeValue, sizeDisplay);
            }, 1000);
            
        } catch (error) {
            debugLog("Error processing people count from guided flow:", error.message);
            
            // Remove typing indicator
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            // Display error message
            const errorMessage = isCzech(displayText)
                ? "Omlouvám se, ale došlo k chybě při zpracování vašeho požadavku. Zkusíme to jinak. Jakou velikost prostoru byste preferovali?"
                : "I'm sorry, but there was an error processing your request. Let's try a different approach. What size space would you prefer?";
            
            addMessage(errorMessage, 'bot');
            conversationHistory.push({role: "assistant", content: errorMessage});
            
            // Restore the guided flow
            conversationState.progressiveFlow = savedFlow;
            
            // Clean up our global variables
            delete window.savedProgressiveFlow;
            delete window.guidedSpaceType;
            
            // Go back to the size selection step
            conversationState.progressiveFlow.currentStep = 2;
            
            // Show the size selection options again
            const nextQuestion = conversationState.progressiveFlow.steps[2].question;
            
            // Create buttons without the help option (to avoid loops)
            const buttons = `<div class="suggestion-buttons">
                <button class="suggestion-button" onclick="handleProgressiveAnswer('up to 100', 'Up to 100 sqm')">Up to 100 sqm</button>
                <button class="suggestion-button" onclick="handleProgressiveAnswer('100-300', '100-300 sqm')">100-300 sqm</button>
                <button class="suggestion-button" onclick="handleProgressiveAnswer('300-500', '300-500 sqm')">300-500 sqm</button>
                <button class="suggestion-button" onclick="handleProgressiveAnswer('500-1000', '500-1000 sqm')">500-1000 sqm</button>
                <button class="suggestion-button" onclick="handleProgressiveAnswer('more than 1000', 'More than 1000 sqm')">More than 1000 sqm</button>
            </div>`;
            
            // Update step indicator
            let stepIndicator = '<div class="step-indicator">';
            for (let i = 0; i < conversationState.progressiveFlow.steps.length; i++) {
                if (i < 2) { // First two steps completed
                    stepIndicator += '<div class="step" style="background-color: #4caf50;"></div>';
                } else if (i === 2) { // Size step is active
                    stepIndicator += '<div class="step active"></div>';
                } else {
                    stepIndicator += '<div class="step"></div>';
                }
            }
            stepIndicator += '</div>';
            
            // Display the size question again
            let message = `${stepIndicator}
            <p>${nextQuestion}</p>
            ${buttons}`;
            
            addMessage(message, 'bot');
            conversationHistory.push({role: "assistant", content: nextQuestion});
        }
    }, 1000);
}
     
// Function to handle refinement button clicks
function handleRefinementClick(refinementType, value) {
    // Get current criteria
    let criteria = {...conversationState.currentSearchCriteria} || {};
    
    // Log the criteria before any changes
    debugLog("Current criteria before refinement:", JSON.stringify(criteria));
    
    // Update criteria based on refinement type
    switch (refinementType) {
        case 'minSize':
            criteria.minSize = value;
            break;
        case 'maxSize':
            criteria.maxSize = value;
            break;
        case 'type':
            criteria.type = value;
            break;
        case 'location':
            criteria.location = value;
            break;
        case 'available':
            criteria.available = value;
            break;
        case 'clearSize':
            // Log the criteria before clearing size
            debugLog("Criteria before clearing size:", JSON.stringify(criteria));
            
            // Remove all size-related fields
            delete criteria.size;
            delete criteria.minSize;
            delete criteria.maxSize;
            
            // Set a flag to indicate we just cleared size restrictions
            criteria.clearSizeAction = true;
            
            // Log after clearing
            debugLog("Criteria after clearing size:", JSON.stringify(criteria));
            break;
        default:
            break;
    }
    
    // Reset pagination offset
    conversationState.offset = 0;
    
    // Update conversation state
    conversationState.currentSearchCriteria = criteria;
    
    // Generate a message to show what we're doing
    const message = `Updating search: ${refinementType} = ${value}`;
    debugLog(message);
    
    // Add user message (showing what refinement was chosen)
    const refinementText = isCzech(document.getElementById('user-input').value) 
        ? `Upřesnit vyhledávání: ${getReadableCriteria(refinementType, value, true)}`
        : `Refine search: ${getReadableCriteria(refinementType, value, false)}`;
    
    addMessage(refinementText, 'user');
    conversationHistory.push({role: "user", content: refinementText});
    
    // Log the final criteria we're searching with
    debugLog("About to search with these criteria:", JSON.stringify(criteria));
    
    // Trigger a new search with updated criteria
    const searchResults = enhancedSearchProperties(criteria);
    
    // Log the search results count
    debugLog(`Search returned ${searchResults.length} results for ${criteria.location} with type ${criteria.type}`);
    
    // Generate and show results
    displaySearchResults(searchResults, criteria);
}

// Function to get readable criteria text
function getReadableCriteria(type, value, isCzechLanguage) {
    if (isCzechLanguage) {
        switch (type) {
            case 'minSize': return `Minimální velikost: ${value} m²`;
            case 'maxSize': return `Maximální velikost: ${value} m²`;
            case 'type': 
                if (value === 'office') return 'Typ: Kanceláře';
                if (value === 'retail') return 'Typ: Obchodní prostory';
                if (value === 'industrial') return 'Typ: Průmyslové prostory';
                return `Typ: ${value}`;
            case 'location': return `Lokalita: ${value}`;
            case 'available': 
                if (value === 'now') return 'Dostupnost: Ihned';
                return `Dostupnost: ${value}`;
            case 'clearSize': return 'Odstranit omezení velikosti';
            default: return `${type}: ${value}`;
        }
    } else {
        switch (type) {
            case 'minSize': return `Minimum size: ${value} sqm`;
            case 'maxSize': return `Maximum size: ${value} sqm`;
            case 'type': return `Type: ${value}`;
            case 'location': return `Location: ${value}`;
            case 'available': 
                if (value === 'now') return 'Availability: Immediate';
                return `Availability: ${value}`;
            case 'clearSize': return 'Clear size restrictions';
            default: return `${type}: ${value}`;
        }
    }
}

// Function to display search results
function displaySearchResults(matchedProperties, criteria) {
    // Add detailed logging about the criteria and results
    debugLog("Displaying search results for criteria:", JSON.stringify(criteria));
    debugLog(`Found ${matchedProperties.length} matching properties`);
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Short timeout to show the typing indicator before showing results
    setTimeout(() => {
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Reset pagination offset
        conversationState.offset = 0;
        
        // Check if we have results
        if (matchedProperties.length > 0) {
            debugLog("Displaying positive search results");
            
            // Generate introduction text
            const isCzechQuery = isCzech(document.getElementById('user-input').value);
            
            // Provide more contextual responses based on filter changes
            let response = "";
            
            // If we just cleared size restrictions, mention it specifically
            if (criteria.clearSizeAction) {
                response = isCzechQuery 
                    ? `Po odstranění filtru velikosti jsem našel ${matchedProperties.length} nemovitostí s těmito parametry:<br><br>`
                    : `After removing size restrictions, I found ${matchedProperties.length} properties with these parameters:<br><br>`;
                
                // Remove the flag after using it
                delete criteria.clearSizeAction;
            } else {
                response = isCzechQuery 
                    ? `Našel jsem ${matchedProperties.length} nemovitostí s těmito parametry:<br><br>`
                    : `I found ${matchedProperties.length} properties with these parameters:<br><br>`;
            }
            
            // Add active filters section
            response += generateActiveFiltersHTML(criteria, isCzechQuery);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, 0, 5);
            
            // Add pagination (now with a button instead of text)
            if (matchedProperties.length > 5) {
                response += isCzechQuery
                    ? `<br>Zobrazuji 1-5 z ${matchedProperties.length} nalezených nemovitostí.<br>`
                    : `<br>Showing 1-5 of ${matchedProperties.length} matching properties.<br>`;
                
                // Add "Show More" button
                response += `<div class="action-button-container">
                    <button class="action-button" onclick="handleShowMore()">${isCzechQuery ? 'Zobrazit další' : 'Show More'}</button>
                </div>`;
            } else {
                response += isCzechQuery
                    ? `<br>Zobrazuji ${matchedProperties.length} z ${matchedProperties.length} nalezených nemovitostí.`
                    : `<br>Showing ${matchedProperties.length} of ${matchedProperties.length} matching properties.`;
            }
            
            // Add refinement buttons
            response += generateRefinementButtonsHTML(criteria, isCzechQuery);
            
            // REMOVED: "You can also ask:" section with suggestion buttons
            
            // Update last shown properties
            conversationState.lastShownProperties = matchedProperties.slice(0, 5).map(p => p.name);
            
            // Display the response
            addMessage(response, 'bot');
            conversationHistory.push({role: "assistant", content: response});
        } else {
            debugLog("No matching properties found, showing suggestions");
            
            // Add logging to help diagnose which filters might be causing the issue
            debugLog("Current criteria causing no results:", JSON.stringify(criteria));
            if (criteria.type) debugLog("Has type filter:", criteria.type);
            if (criteria.location) debugLog("Has location filter:", criteria.location);
            if (criteria.size || criteria.minSize || criteria.maxSize) {
                debugLog("Has size filters:", 
                    criteria.size ? `size=${criteria.size}` : '', 
                    criteria.minSize ? `minSize=${criteria.minSize}` : '', 
                    criteria.maxSize ? `maxSize=${criteria.maxSize}` : '');
            }
            if (criteria.available) debugLog("Has availability filter:", criteria.available);
            
            // No results found
            const isCzechQuery = isCzech(document.getElementById('user-input').value);
            let noResultsResponse = isCzechQuery
                ? `Bohužel jsem nenašel žádné nemovitosti odpovídající těmto kritériím.<br><br>`
                : `I couldn't find any properties matching these criteria.<br><br>`;
            
            // Add active filters section
            noResultsResponse += generateActiveFiltersHTML(criteria, isCzechQuery);
            
            // Add suggestion to modify search with more targeted recommendations
            noResultsResponse += isCzechQuery
                ? `<p>Zkuste upravit vyhledávací kritéria pro více výsledků:</p>`
                : `<p>Try modifying your search criteria for more results:</p>`;
            
            // Add buttons to relax search criteria
            noResultsResponse += `<div class="suggestion-buttons">`;
            
            // Suggest clearing size filters if they exist
            if (criteria.minSize || criteria.maxSize || criteria.size) {
                noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('clearSize', '')">${isCzechQuery ? 'Odstranit omezení velikosti' : 'Remove size restrictions'}</button>`;
            }
            
            // If availability is set to something other than "Any", suggest changing it
            if (criteria.available && criteria.available.toLowerCase() !== 'any') {
                noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('available', 'Any')">${isCzechQuery ? 'Jakákoli dostupnost' : 'Any availability'}</button>`;
            }
            
            // More buttons to try different locations or types
            if (criteria.type) {
                const types = ['office', 'retail', 'industrial'].filter(t => t !== criteria.type);
                types.forEach(type => {
                    const typeLabel = type === 'office' 
                        ? (isCzechQuery ? 'Kanceláře' : 'Office')
                        : type === 'retail' 
                            ? (isCzechQuery ? 'Obchodní prostory' : 'Retail')
                            : (isCzechQuery ? 'Průmyslové prostory' : 'Industrial');
                    
                    noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('type', '${type}')">${typeLabel}</button>`;
                });
            }
            
            if (criteria.location) {
                const locations = ['Prague', 'Brno', 'Ostrava'].filter(l => !criteria.location.includes(l));
                locations.forEach(location => {
                    noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('location', '${location}')">${location}</button>`;
                });
            }
            
            noResultsResponse += `</div>`;
            
            // Display the response
            addMessage(noResultsResponse, 'bot');
            conversationHistory.push({role: "assistant", content: noResultsResponse});
        }
    }, 500);
}

// Function to generate active filters HTML
function generateActiveFiltersHTML(criteria, isCzechQuery) {
    let filtersHTML = '';
    const hasFilters = Object.keys(criteria).length > 0 && 
                     (criteria.type || criteria.location || criteria.minSize || 
                      criteria.maxSize || criteria.size || criteria.available);
    
    if (hasFilters) {
        filtersHTML += `<div class="active-filters">
            <div style="width:100%; margin-bottom:5px; font-size:12px; color:#666;">
                ${isCzechQuery ? 'Aktivní filtry:' : 'Active filters:'}
            </div>`;
        
        if (criteria.type) {
            const typeLabel = criteria.type === 'office' 
                ? (isCzechQuery ? 'Kanceláře' : 'Office')
                : criteria.type === 'retail' 
                    ? (isCzechQuery ? 'Obchodní prostory' : 'Retail')
                    : (isCzechQuery ? 'Průmyslové prostory' : 'Industrial');
            
            filtersHTML += `<div class="filter-tag">${typeLabel}</div>`;
        }
        
        if (criteria.location) {
            filtersHTML += `<div class="filter-tag">${criteria.location}</div>`;
        }
        
        if (criteria.size) {
            filtersHTML += `<div class="filter-tag">${isCzechQuery ? 'Přibližně' : 'Around'} ${criteria.size} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        } else if (criteria.minSize && criteria.maxSize) {
            filtersHTML += `<div class="filter-tag">${criteria.minSize}-${criteria.maxSize} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        } else if (criteria.minSize) {
            filtersHTML += `<div class="filter-tag">${isCzechQuery ? 'Min' : 'Min'} ${criteria.minSize} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        } else if (criteria.maxSize) {
            filtersHTML += `<div class="filter-tag">${isCzechQuery ? 'Max' : 'Max'} ${criteria.maxSize} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        }
        
        if (criteria.available) {
            const availLabel = criteria.available === 'now'
                ? (isCzechQuery ? 'Dostupné ihned' : 'Available now')
                : criteria.available;
            
            filtersHTML += `<div class="filter-tag">${availLabel}</div>`;
        }
        
        filtersHTML += `</div>`;
    }
    
    return filtersHTML;
}
   // Function to generate refinement buttons HTML
function generateRefinementButtonsHTML(criteria, isCzechQuery) {
    let buttonsHTML = `<div class="refinement-buttons">
        <div style="width:100%; margin-bottom:5px; font-size:12px; color:#666;">
            ${isCzechQuery ? 'Upřesnit vyhledávání:' : 'Refine your search:'}
        </div>`;
    
    // Size refinements - UPDATED to match the guided search
    if (!criteria.minSize && !criteria.maxSize) {
        // Add size options that match the guided search
        buttonsHTML += `<button class="refinement-button" onclick="handleSizeHelpClickFromRefinement()">
        ${isCzechQuery ? 'Pomoc s výběrem velikosti' : 'Help me with size'}
        </button>`;
            
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('maxSize', '100')">
            ${isCzechQuery ? 'Do 100 m²' : 'Up to 100 sqm'}
        </button>`;
            
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('minSize', '100'); handleRefinementClick('maxSize', '300');">
            ${isCzechQuery ? '100-300 m²' : '100-300 sqm'}
        </button>`;
            
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('minSize', '300'); handleRefinementClick('maxSize', '500');">
            ${isCzechQuery ? '300-500 m²' : '300-500 sqm'}
        </button>`;
            
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('minSize', '500'); handleRefinementClick('maxSize', '1000');">
            ${isCzechQuery ? '500-1000 m²' : '500-1000 sqm'}
        </button>`;
            
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('minSize', '1000')">
            ${isCzechQuery ? 'Více než 1000 m²' : 'More than 1000 sqm'}
        </button>`;
    } else {
        // Option to clear size filter if one is applied
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('clearSize', '')">
            ${isCzechQuery ? 'Odstranit omezení velikosti' : 'Clear size filter'}
        </button>`;
    }
    
    // Type refinements (if not already specified)
    if (!criteria.type) {
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('type', 'office')">
            ${isCzechQuery ? 'Kanceláře' : 'Office'}
        </button>
        <button class="refinement-button" onclick="handleRefinementClick('type', 'retail')">
            ${isCzechQuery ? 'Obchodní prostory' : 'Retail'}
        </button>
        <button class="refinement-button" onclick="handleRefinementClick('type', 'industrial')">
            ${isCzechQuery ? 'Průmyslové prostory' : 'Industrial'}
        </button>`;
    }
    
    // Location refinements (if not already specified)
    if (!criteria.location) {
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('location', 'Prague')">Prague</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Brno')">Brno</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Ostrava')">Ostrava</button>`;
    } else if (criteria.location === 'Prague' && !criteria.location.includes('Prague ')) {
        // Add ALL Prague district options (1-10)
        buttonsHTML += `
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 1')">Prague 1</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 2')">Prague 2</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 3')">Prague 3</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 4')">Prague 4</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 5')">Prague 5</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 6')">Prague 6</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 7')">Prague 7</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 8')">Prague 8</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 9')">Prague 9</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 10')">Prague 10</button>`;
    }
    
    // Availability refinement
    if (!criteria.available) {
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('available', 'now')">
            ${isCzechQuery ? 'Dostupné ihned' : 'Available now'}
        </button>`;
    }
    
    buttonsHTML += `</div>`;
    
    return buttonsHTML;
}

// Function to generate suggestion buttons HTML - UPDATED
function generateSuggestionButtonsHTML(criteria, isCzechQuery) {
    // Check if this is at the end of a guided search flow
    const isAfterGuidedSearch = 
        criteria && 
        criteria.type && 
        criteria.location && 
        (criteria.size || criteria.minSize || criteria.maxSize) &&
        criteria.available;
    
    // If we're at the end of a guided search, don't show any suggestions
    if (isAfterGuidedSearch) {
        return ''; // Return empty string instead of suggestion buttons
    }
    
    // Otherwise, continue with the normal suggestion buttons
    let buttonsHTML = `<div class="suggestion-buttons">
        <div style="width:100%; margin-bottom:5px; font-size:12px; color:#666;">
            ${isCzechQuery ? 'Můžete se také zeptat:' : 'You can also ask:'}
        </div>`;
    
    // Add "Help me with size" button as the first option - USING DIRECT HANDLER
    buttonsHTML += `<button class="suggestion-button" onclick="handleSizeHelpClick()">
        ${isCzechQuery ? 'Pomoc s výběrem velikosti' : 'Help me with size'}
    </button>`;
    
    // Generate relevant suggestions based on current criteria
    if (criteria.type && criteria.location) {
        // They already specified type and location, suggest size-related questions
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Jaké jsou velikosti ' + criteria.type + ' v ' + criteria.location + '?' : 'What sizes of ' + criteria.type + ' space do you have in ' + criteria.location + '?'}')">
            ${isCzechQuery ? 'Jaké jsou velikosti?' : 'What sizes available?'}
        </button>`;
        
        // Other size-related options
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Největší ' + criteria.type + ' v ' + criteria.location : 'Largest ' + criteria.type + ' in ' + criteria.location}')">
            ${isCzechQuery ? 'Největší prostory' : 'Largest spaces'}
        </button>`;
        
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Dostupnost ' + criteria.type + ' v ' + criteria.location : 'Availability of ' + criteria.type + ' in ' + criteria.location}')">
            ${isCzechQuery ? 'Kdy jsou dostupné?' : 'When available?'}
        </button>`;
    } else if (criteria.type) {
        // They specified type but not location
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Kde máte ' + criteria.type + '?' : 'Where do you have ' + criteria.type + ' space?'}')">
            ${isCzechQuery ? 'Kde máte ' + criteria.type + '?' : 'Where are your ' + criteria.type + ' spaces?'}
        </button>`;
        
        // Suggest popular locations
        ['Prague', 'Brno', 'Ostrava'].forEach(location => {
            buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? criteria.type + ' v ' + location : criteria.type + ' in ' + location}')">
                ${isCzechQuery ? criteria.type + ' v ' + location : criteria.type + ' in ' + location}
            </button>`;
        });
    } else if (criteria.location) {
        // They specified location but not type
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Jaké typy nemovitostí máte v ' + criteria.location + '?' : 'What types of properties do you have in ' + criteria.location + '?'}')">
            ${isCzechQuery ? 'Jaké typy nemovitostí máte v ' + criteria.location + '?' : 'What types of properties in ' + criteria.location + '?'}
        </button>`;
        
        // Suggest different property types
        const types = [
            { value: 'office', labelCz: 'Kanceláře', labelEn: 'Office space' },
            { value: 'retail', labelCz: 'Obchodní prostory', labelEn: 'Retail space' },
            { value: 'industrial', labelCz: 'Průmyslové prostory', labelEn: 'Industrial space' }
        ];
        
        types.forEach(type => {
            buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? type.labelCz + ' v ' + criteria.location : type.labelEn + ' in ' + criteria.location}')">
                ${isCzechQuery ? type.labelCz + ' v ' + criteria.location : type.labelEn + ' in ' + criteria.location}
            </button>`;
        });
    } else {
        // No specific criteria yet, suggest common starting points
        const suggestions = isCzechQuery 
            ? ['Kancelářské prostory v Praze', 'Obchodní prostory v centru', 'Průmyslové prostory větší než 1000 m²', 'Prostory pro 50 lidí'] 
            : ['Office space in Prague', 'Retail space in city center', 'Industrial space larger than 1000 sqm', 'Space for 50 people'];
        
        suggestions.forEach(suggestion => {
            buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${suggestion}')">
                ${suggestion}
            </button>`;
        });
    }
    
    buttonsHTML += `</div>`;
    
    return buttonsHTML;
}

// Function to handle "Show More" button click
function handleShowMore() {
    // Add user message
    const moreText = isCzech(document.getElementById('user-input').value) ? "Zobrazit další" : "Show more";
    addMessage(moreText, 'user');
    conversationHistory.push({role: "user", content: moreText});
    
    // Increase offset
    conversationState.offset += 5;
    
    // Get current criteria
    const criteria = {...conversationState.currentSearchCriteria} || {};
    
    // Search for matching properties
    const matchedProperties = enhancedSearchProperties(criteria);
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Short timeout to show the typing indicator before showing results
    setTimeout(() => {
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Generate response
        const isCzechQuery = isCzech(document.getElementById('user-input').value);
        let response = isCzechQuery 
            ? `Ano, zde jsou další nemovitosti, které splňují vaše kritéria:<br><br>`
            : `Yes, here are more properties that match your criteria:<br><br>`;
        
        // Get the relevant slice for pagination
        const start = conversationState.offset;
        const end = conversationState.offset + 5;
        const propertiesToShow = matchedProperties.slice(start, end);
        
        // If no properties to show at current offset but we have matches, wrap around
        if (propertiesToShow.length === 0 && matchedProperties.length > 0) {
            // Reset offset to 0 and show the first page
            conversationState.offset = 0;
            
            response = isCzechQuery 
                ? `Došli jsme na konec výsledků. Zde jsou znovu první nemovitosti:<br><br>`
                : `We've reached the end of the results. Here are the first properties again:<br><br>`;
                
            // Update properties to show
            const firstPageProperties = matchedProperties.slice(0, 5);
            // Update last shown properties
            conversationState.lastShownProperties = firstPageProperties.map(p => p.name);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, 0, 5);
        } else {
            // Update last shown properties
            conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, conversationState.offset, 5);
        }
        
        // Add pagination information with Show More button
        const nextBatch = conversationState.offset + 5;
        const remaining = matchedProperties.length - nextBatch;
        
        if (remaining > 0) {
            response += isCzechQuery
                ? `<br>Zobrazuji ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.<br>`
                : `<br>Showing ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} of ${matchedProperties.length} matching properties.<br>`;
            
            // Add "Show More" button
            response += `<div class="action-button-container">
                <button class="action-button" onclick="handleShowMore()">${isCzechQuery ? 'Zobrazit další' : 'Show More'}</button>
            </div>`;
        } else {
            response += isCzechQuery
                ? `<br>Zobrazuji ${conversationState.offset + 1}-${matchedProperties.length} z ${matchedProperties.length} nalezených nemovitostí.`
                : `<br>Showing ${conversationState.offset + 1}-${matchedProperties.length} of ${matchedProperties.length} matching properties.`;
        }
        
        // Display the response
        addMessage(response, 'bot');
        conversationHistory.push({role: "assistant", content: response});
    }, 500);
}

// Function to start a progressive conversation
function startProgressiveConversation() {
    const steps = [
        { question: 'What type of commercial property are you looking for?', field: 'type' },
        { question: 'Where would you like the property to be located?', field: 'location' },
        { question: 'What size range are you interested in (in sqm)?', field: 'size' },
        { question: 'When do you need the space to be available?', field: 'available' }
    ];
    
    // Store the conversation flow in the state
    conversationState.progressiveFlow = {
        steps: steps,
        currentStep: 0,
        answers: {}
    };
    
    // Display the first question
    const firstQuestion = steps[0].question;
    
    // Add contextual buttons for the first question
    let buttons = '';
    
    if (steps[0].field === 'type') {
        buttons = `<div class="suggestion-buttons">
            <button class="suggestion-button" onclick="handleProgressiveAnswer('office', 'Office space')">Office space</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('retail', 'Retail space')">Retail space</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('industrial', 'Industrial space')">Industrial space</button>
        </div>`;
    }
    
    // Display the first question with step indicator
    let message = `<div class="step-indicator">
        <div class="step active"></div>
        <div class="step"></div>
        <div class="step"></div>
        <div class="step"></div>
    </div>
    <p>${firstQuestion}</p>
    ${buttons}`;
    
    addMessage(message, 'bot');
    conversationHistory.push({role: "assistant", content: firstQuestion});
}

// Function to handle progressive answers
function handleProgressiveAnswer(value, displayText) {
    // First, display the user's answer
    addMessage(displayText, 'user');
    conversationHistory.push({role: "user", content: displayText});
    
    // Get the current flow
    const flow = conversationState.progressiveFlow;
    if (!flow) return;
    
    // Save the answer
    const currentField = flow.steps[flow.currentStep].field;
    flow.answers[currentField] = value;
    
    // Move to the next step
    flow.currentStep++;
    
    // Check if we've completed all steps
    if (flow.currentStep >= flow.steps.length) {
        // We're done, perform the search with collected criteria
        const criteria = {
            type: flow.answers.type,
            location: flow.answers.location
        };
        
        // Handle size (could be a range or single value)
        if (flow.answers.size === 'up to 100') {
            criteria.maxSize = '100';
        } else if (flow.answers.size === 'more than 1000') {
            criteria.minSize = '1000';
        } else if (flow.answers.size && flow.answers.size.includes('-')) {
            const [min, max] = flow.answers.size.split('-');
            criteria.minSize = min.trim();
            criteria.maxSize = max.trim();
        } else if (flow.answers.size) {
            criteria.size = flow.answers.size;
        }
        
        // Handle availability
        if (flow.answers.available) {
            criteria.available = flow.answers.available;
        }
        
        // Update conversation state
        conversationState.currentSearchCriteria = criteria;
        
        // Show typing indicator
        const typingIndicator = document.createElement('div');
        typingIndicator.className = 'typing-indicator';
        typingIndicator.textContent = 'Typing...';
        typingIndicator.id = 'typing-indicator';
        document.getElementById('messages').appendChild(typingIndicator);
        
        // Short timeout to show the typing indicator
        setTimeout(() => {
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            // Reset the progressive flow
            delete conversationState.progressiveFlow;
            
            // Search for matching properties
            const matchedProperties = enhancedSearchProperties(criteria);
            
            // Display results
            displaySearchResults(matchedProperties, criteria);
        }, 1000);
        
        return;
    }
    
    // Display the next question
    const nextQuestion = flow.steps[flow.currentStep].question;
    let buttons = '';
    
  // Add contextual buttons based on the current field
if (flow.steps[flow.currentStep].field === 'location') {
    buttons = `<div class="suggestion-buttons">
        <button class="suggestion-button" onclick="handleProgressiveAnswer('Prague', 'Prague')">Prague</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('Brno', 'Brno')">Brno</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('Ostrava', 'Ostrava')">Ostrava</button>
    </div>`;
} else if (flow.steps[flow.currentStep].field === 'size') {
    // Add "Help me with size" option to the size selection step
    const isCzechQuery = isCzech(document.getElementById('user-input').value);
    buttons = `<div class="suggestion-buttons">
        <button class="suggestion-button" onclick="handleSizeHelpFromGuided('${flow.answers.type || 'office'}')">
            ${isCzechQuery ? 'Pomoc s výběrem velikosti' : 'Help me with size'}
        </button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('up to 100', 'Up to 100 sqm')">Up to 100 sqm</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('100-300', '100-300 sqm')">100-300 sqm</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('300-500', '300-500 sqm')">300-500 sqm</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('500-1000', '500-1000 sqm')">500-1000 sqm</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('more than 1000', 'More than 1000 sqm')">More than 1000 sqm</button>
    </div>`;
} else if (flow.steps[flow.currentStep].field === 'available') {
    buttons = `<div class="suggestion-buttons">
        <button class="suggestion-button" onclick="handleProgressiveAnswer('now', 'Immediately')">Immediately</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('Q3 2025', 'Q3 2025')">Q3 2025</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('Q4 2025', 'Q4 2025')">Q4 2025</button>
        <button class="suggestion-button" onclick="handleProgressiveAnswer('Any', 'Any time')">Any time</button>
    </div>`;
}
    // Update step indicator
    let stepIndicator = '<div class="step-indicator">';
    for (let i = 0; i < flow.steps.length; i++) {
        if (i < flow.currentStep) {
            stepIndicator += '<div class="step" style="background-color: #4caf50;"></div>'; // Completed steps
        } else if (i === flow.currentStep) {
            stepIndicator += '<div class="step active"></div>'; // Current step
        } else {
            stepIndicator += '<div class="step"></div>'; // Future steps
        }
    }
    stepIndicator += '</div>';
    
    // Display the next question
    let message = `${stepIndicator}
    <p>${nextQuestion}</p>
    ${buttons}`;
    
    addMessage(message, 'bot');
    conversationHistory.push({role: "assistant", content: nextQuestion});
}

// Add listener for debug command
document.getElementById('user-input').addEventListener('input', function(e) {
    if (e.target.value.trim().toLowerCase() === "!test api") {
        e.target.style.backgroundColor = "#e8f4ff";
    } else {
        e.target.style.backgroundColor = "";
    }
});

// This function intercepts button clicks and prevents them from being added to the message history twice
document.addEventListener('click', function(e) {
    if (e.target && e.target.matches('.suggestion-button, .refinement-button, .action-button')) {
        e.preventDefault();
        // The actual functionality is handled via onclick attributes on the buttons
    }
});

// Add handleSuggestionClick and other functions to window so they can be called from onclick
window.handleSuggestionClick = handleSuggestionClick;
window.handleSizeHelpClick = handleSizeHelpClick;
window.handleSizeHelpFromGuided = handleSizeHelpFromGuided;
window.handlePeopleCountFromGuided = handlePeopleCountFromGuided;
window.handleRefinementClick = handleRefinementClick;
window.handleShowMore = handleShowMore;
window.startProgressiveConversation = startProgressiveConversation;
window.handleProgressiveAnswer = handleProgressiveAnswer;
window.handlePeopleCountClick = handlePeopleCountClick;
window.showPragueDistrictOptions = showPragueDistrictOptions; 
window.handleSizeHelpClickFromRefinement = handleSizeHelpClickFromRefinement; // Add this line
</script>
</body>
</html>  
