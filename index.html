<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integis Property Assistant</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: transparent;
        }
        
        .chat-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        
        .chat-header {
            background-color: #0078d4;
            color: white;
            padding: 15px;
            font-weight: bold;
            text-align: center;
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: #f8f8f8;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            clear: both;
        }
        
        .user-message {
            background-color: #0078d4;
            color: white;
            float: right;
        }
        
        .bot-message {
            background-color: #e9e9e9;
            color: #333;
            float: left;
        }
        
        .input-container {
            display: flex;
            padding: 15px;
            background-color: #fff;
            border-top: 1px solid #eee;
        }
        
        #user-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 14px;
        }
        
        #send-button {
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 0 20px;
            cursor: pointer;
            font-weight: bold;
        }
        
        #send-button:hover {
            background-color: #0069b8;
        }
        
        .property-item {
            margin: 12px 0;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(0, 120, 212, 0.05);
            border-left: 3px solid #0078d4;
        }
        
        .property-name {
            font-weight: bold;
            color: #0078d4;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .property-details {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .property-detail {
            background-color: #f0f0f0;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.9em;
        }
        
        .typing-indicator {
            background-color: #e9e9e9;
            color: #666;
            padding: 8px 15px;
            border-radius: 18px;
            margin-bottom: 15px;
            display: inline-block;
            float: left;
            clear: both;
        }
        
        /* For iframe embedding, ensure proper sizing */
        @media (max-width: 500px) {
            .chat-container {
                max-width: 100%;
                max-height: 100%;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
        
        /* Clear floats after messages */
        .clearfix::after {
            content: "";
            clear: both;
            display: table;
        }
        
        /* Reset button */
        #reset-chat {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.8;
        }
        
        #reset-chat:hover {
            opacity: 1;
        }
        
        /* Debug panel for development */
        .debug-panel {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 200px;
            background-color: rgba(0,0,0,0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 10px;
            overflow-y: auto;
            z-index: 1000;
            display: none; /* Hidden by default, enable for debugging */
        }
  /* Suggestion Buttons */
    .suggestion-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
    }
    
    .suggestion-button {
        background-color: #f0f7ff;
        color: #0078d4;
        border: 1px solid #0078d4;
        border-radius: 16px;
        padding: 6px 12px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .suggestion-button:hover {
        background-color: #0078d4;
        color: white;
    }
    
    /* Refinement Buttons */
    .refinement-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 12px 0;
    }
    
    .refinement-button {
        background-color: #f5f5f5;
        color: #555;
        border: 1px solid #ddd;
        border-radius: 16px;
        padding: 6px 12px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .refinement-button:hover {
        background-color: #eee;
        border-color: #bbb;
    }
    
    /* Action Buttons (like "Show More") */
    .action-button {
        background-color: #0078d4;
        color: white;
        border: none;
        border-radius: 16px;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-top: 8px;
        display: inline-block;
    }
    
    .action-button:hover {
        background-color: #0069b8;
    }
    
    /* Active filters display */
    .active-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 12px 0;
        padding: 8px;
        background-color: #f8f8f8;
        border-radius: 8px;
    }
    
    .filter-tag {
        background-color: #e0f0ff;
        color: #0078d4;
        border-radius: 12px;
        padding: 4px 10px;
        font-size: 12px;
        display: flex;
        align-items: center;
    }
    
    .filter-tag .remove {
        margin-left: 6px;
        font-weight: bold;
        cursor: pointer;
    }
    
    /* Step indicator for progressive conversations */
    .step-indicator {
        display: flex;
        justify-content: center;
        margin: 12px 0;
    }
    
    .step {
        width: 8px;
        height: 8px;
        background-color: #ddd;
        border-radius: 50%;
        margin: 0 4px;
    }
    
    .step.active {
        background-color: #0078d4;
        width: 10px;
        height: 10px;
    }
</style>
    
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            Integis Property Assistant
            <button id="reset-chat">New Chat</button>
        </div>
        <div id="messages" class="messages-container"></div>
        <div class="input-container">
            <input type="text" id="user-input" placeholder="Ask about our properties...">
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <!-- Debug panel (for development) -->
    <div id="debug-panel" class="debug-panel"></div>

    <script>
        // Debug flag - set to true to show debug panel and logs
        const DEBUG_MODE = true;
        
        // Initialize properties array
        let properties = [];
        let propertiesLoaded = false;
        
        // Conversation history - store the entire conversation
        let conversationHistory = [];

        // Conversation state - track state across interactions
        let conversationState = {
            currentSearchCriteria: null,
            lastShownProperties: [],
            offset: 0, // For pagination of results
            lastQuery: "",
            lastResponse: ""
        };

        // Gemini API Configuration
        const GEMINI_API_KEY = "AIzaSyBu8k9YArazXs1MXrKzxctJiYz85LMD850";
        const GEMINI_MODEL = "gemini-2.0-flash";
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";

        // Debug logger function
        function debugLog(message, obj = null) {
            if (DEBUG_MODE) {
                console.log(message, obj || '');
                
                const panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.style.display = 'block';
                    
                    const logEntry = document.createElement('div');
                    logEntry.textContent = `${new Date().toISOString().substr(11, 8)} - ${message}`;
                    
                    if (obj) {
                        const objStr = typeof obj === 'string' ? obj : JSON.stringify(obj);
                        if (objStr.length > 200) {
                            logEntry.textContent += ` ${objStr.substr(0, 200)}...`;
                        } else {
                            logEntry.textContent += ` ${objStr}`;
                        }
                    }
                    
                    panel.appendChild(logEntry);
                    panel.scrollTop = panel.scrollHeight;
                    
                    // Limit entries to prevent browser slowdown
                    while (panel.childElementCount > 100) {
                        panel.removeChild(panel.firstChild);
                    }
                }
            }
        }

        // Helper function to determine if input is Czech
        function isCzech(text) {
            return /[áčďéěíňóřšťúůýž]/i.test(text);
        }

        // Function to load properties from JSON file
        async function loadProperties() {
            try {
                debugLog("Loading properties from JSON file...");
                const loadingMessage = addMessage("Loading property listings...", 'bot');
                
                const response = await fetch('properties.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                properties = await response.json();
                propertiesLoaded = true;
                
                debugLog(`Successfully loaded ${properties.length} properties`);
                loadingMessage.innerHTML = `Property listings loaded successfully! I now have information about ${properties.length} properties.`;
                
                return true;
            } catch (error) {
                debugLog("Error loading properties:", error.message);
                const loadingMessage = document.querySelector('.bot-message:last-child');
                if (loadingMessage) {
                    loadingMessage.innerHTML = "I'm having trouble loading the property listings. Please try again later.";
                }
                return false;
            }
        }

                // Add welcome message and load properties when page loads
        window.addEventListener('load', async function() {
            // Add welcome message
            const welcomeMessage = "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?<br><br><button class='action-button' onclick='startProgressiveConversation()'>Start Guided Search</button>";
            addMessage(welcomeMessage, 'bot');
            
            // Add to conversation history (without the HTML)
            conversationHistory.push({role: "assistant", content: "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?"});
            
            // Load properties
            await loadProperties();
            
            if (DEBUG_MODE) {
                debugLog("Debug mode enabled. Showing debug panel.");
                document.getElementById('debug-panel').style.display = 'block';
            }
});

        // Reset chat button - UPDATED to clear conversation state
        document.getElementById('reset-chat').addEventListener('click', function() {
            // Clear conversation history
            conversationHistory = [];
            
            // Reset conversation state
            conversationState = {
                currentSearchCriteria: null,
                lastShownProperties: [],
                offset: 0,
                lastQuery: "",
                lastResponse: ""
            };
            
            // Clear messages
            document.getElementById('messages').innerHTML = '';
            
            // Add welcome message
            const welcomeMessage = "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?";
            addMessage(welcomeMessage, 'bot');
            
            // Add to conversation history
            conversationHistory.push({role: "assistant", content: welcomeMessage});
            
            debugLog("Chat reset, conversation state cleared");
        });

        // Send button click event
        document.getElementById('send-button').addEventListener('click', function() {
            const input = document.getElementById('user-input').value.trim().toLowerCase();
            
            if (input === "!test api") {
                document.getElementById('user-input').value = '';
                testGeminiAPI();
                return; // Add return statement to prevent normal message processing
            } else {
                sendMessage();
            }
        });

        // Enter key press event
        document.getElementById('user-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const input = document.getElementById('user-input').value.trim().toLowerCase();
                if (input === "!test api") {
                    document.getElementById('user-input').value = '';
                    testGeminiAPI();
                    return; // Add return statement to prevent normal message processing
                }
                sendMessage();
            }
        });

        // Improved follow-up detection
        function isFollowUpQuestion(userInput) {
            // First, check for obvious follow-up phrases
            const followUpPhrases = /more|additional|another|further|similar|like that|such|tell me more|show more|any other|else|next|other|další|více|ještě|také|další|podobné/i;
            
            if (followUpPhrases.test(userInput)) {
                return true;
            }
            
            // Check for very short queries that likely reference previous context
            if (userInput.split(/\s+/).length < 4 && conversationState.currentSearchCriteria) {
                return true;
            }
            
            // Check for queries that only specify one parameter but we have other parameters saved
            const hasOnlySize = /\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)/i.test(userInput) && 
                               !/office|retail|industrial|prague|brno|ostrava|kancelář|obchod|průmysl/i.test(userInput);
            
            const hasOnlyLocation = /prague|praha|brno|ostrava/i.test(userInput) && 
                                   !/\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)|office|retail|industrial|kancelář|obchod|průmysl/i.test(userInput);
            
            const hasOnlyType = /office|retail|industrial|kancelář|obchod|průmysl/i.test(userInput) && 
                                !/\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)|prague|praha|brno|ostrava/i.test(userInput);
            
            if ((hasOnlySize || hasOnlyLocation || hasOnlyType) && conversationState.currentSearchCriteria) {
                return true;
            }
            
            return false;
        }

        // Extract search criteria from user input
        function extractSearchCriteria(userInput, previousCriteria = null) {
            debugLog("Extracting search criteria from:", userInput);
            let criteria = previousCriteria ? {...previousCriteria} : {};
            
            // Extract location
            if (/prague|praha/i.test(userInput)) {
                // Handle Prague and its districts
                criteria.location = "Prague";
                
                // Look for Praha/Prague followed by a number (district)
                const pragueDistrictMatches = userInput.match(/prague\s*(\d+)|praha\s*(\d+)/gi);
                if (pragueDistrictMatches && pragueDistrictMatches.length > 0) {
                    // If we found district numbers, use the full match as the location
                    // This will preserve "Prague 1 or Prague 2" type queries
                    if (userInput.toLowerCase().includes(' or ') && pragueDistrictMatches.length > 1) {
                        // Multiple districts with "or" - capture the whole phrase
                        let districtPhrase = "Prague";
                        pragueDistrictMatches.forEach(match => {
                            const distNum = match.match(/\d+/)[0];
                            districtPhrase += ` ${distNum} or Prague`;
                        });
                        // Remove the trailing " or Prague"
                        districtPhrase = districtPhrase.replace(/ or Prague$/, '');
                        criteria.location = districtPhrase;
                    } else {
                        // Single district or no "or" connector
                        const firstMatch = pragueDistrictMatches[0];
                        const distNum = firstMatch.match(/\d+/)[0];
                        criteria.location = `Prague ${distNum}`;
                    }
                }
            } else if (/brno/i.test(userInput)) {
                criteria.location = "Brno";
            } else if (/ostrava/i.test(userInput)) {
                criteria.location = "Ostrava";
            }
            
            // Extract property type
            if (/office|kancelář/i.test(userInput)) {
                criteria.type = "office";
            } else if (/retail|obchod/i.test(userInput)) {
                criteria.type = "retail";
            } else if (/industrial|průmysl|sklad/i.test(userInput)) {
                criteria.type = "industrial";
            }
            
            // NEW: Check for people-based sizing
            const peopleMatch = userInput.match(/(\d+)\s*(?:people|persons|employees|staff|workers|colleagues|team members|osoby|lidí|zaměstnanců|pracovníků)/i);
            if (peopleMatch) {
                const numberOfPeople = parseInt(peopleMatch[1]);
                if (!isNaN(numberOfPeople)) {
                    // Flag that this is a people-based query that needs Gemini processing
                    criteria.peopleCount = numberOfPeople;
                    debugLog(`Detected people-based query: ${numberOfPeople} people`);
                }
            }
            
            // Extract size "between X and Y" pattern
            const betweenMatch = userInput.match(/between\s+(\d+)\s+and\s+(\d+)/i) || 
                               userInput.match(/from\s+(\d+)\s+to\s+(\d+)/i);
            
            if (betweenMatch) {
                criteria.minSize = betweenMatch[1];
                criteria.maxSize = betweenMatch[2];
                debugLog(`Detected size range: ${criteria.minSize}-${criteria.maxSize} sqm`);
            } else {
                // If no "between" pattern, check for individual size specifications
                
                // Check for size
                const sizeMatch = userInput.match(/(\d+)\s*(?:sq\s*m|sqm|square meter|m2|metr)/i);
                if (sizeMatch) {
                    criteria.size = sizeMatch[1];
                }
                
                // Check for "less than" or "under" size specification
                const underSizeMatch = userInput.match(/(?:less than|under|smaller than|max|maximum|do|méně než|pod|maximálně)\s*(\d+)/i);
                if (underSizeMatch) {
                    criteria.maxSize = underSizeMatch[1];
                }
                
                // Check for "more than" or "over" size specification
                const overSizeMatch = userInput.match(/(?:more than|over|larger than|min|minimum|nad|více než|minimálně)\s*(\d+)/i);
                if (overSizeMatch) {
                    criteria.minSize = overSizeMatch[1];
                }
            }
            
            // Check for price mentions
            if (/€|eur|euro|czk|kč|price|cost|rent|nájem/i.test(userInput)) {
                criteria.price = ""; // Just flag that price is important
            }
            
            // Check for availability mentions
            if (/available|now|immediately|ihned|dostupn/i.test(userInput)) {
                criteria.available = "now";
            } else if (/q[1-4]|quarter|quartal|kvartál|202[0-9]/i.test(userInput)) {
                criteria.available = ""; // Just flag that specific availability is important
            }
            
            debugLog("Extracted search criteria:", criteria);
            return criteria;
        }

        // Enhanced search function with proper Prague district handling
        function enhancedSearchProperties(criteria) {
            debugLog("Searching properties with criteria:", criteria);
            let results = [...properties];
            
            // First, handle Prague district special case
            if (criteria.location && criteria.location.toLowerCase().includes('prague')) {
                debugLog("Processing Prague district search");
                
                // Extract district number if present
                const pragueDistrictMatch = criteria.location.match(/prague\s*(\d+)/i);
                const pragueDistricts = [];
                
                if (pragueDistrictMatch && pragueDistrictMatch[1]) {
                    // If a specific district is mentioned, add it to the array
                    pragueDistricts.push(pragueDistrictMatch[1]);
                    debugLog(`Looking specifically for Prague district ${pragueDistrictMatch[1]}`);
                    
                    // Handle "Prague 1 or Prague 2" type queries by checking for multiple districts
                    if (criteria.location.toLowerCase().includes('or')) {
                        const additionalDistricts = criteria.location.toLowerCase().match(/prague\s*(\d+)/gi);
                        if (additionalDistricts && additionalDistricts.length > 1) {
                            for (let districtMatch of additionalDistricts) {
                                const distNum = districtMatch.match(/prague\s*(\d+)/i)[1];
                                if (!pragueDistricts.includes(distNum)) {
                                    pragueDistricts.push(distNum);
                                }
                            }
                            debugLog(`Multiple Prague districts requested: ${pragueDistricts.join(', ')}`);
                        }
                    }
                }
                
                // Filter for Prague properties with matching district if districts specified
                if (pragueDistricts.length > 0) {
                    results = results.filter(p => {
                        // First check that this is a Prague property
                        const isPrague = (p.city && p.city.toLowerCase().includes('prague')) || 
                                        (p.location && p.location.toLowerCase().includes('prague'));
                        
                        if (!isPrague) return false;
                        
                        // Then check for district match
                        let districtMatch = false;
                        
                        // Check in the district field if it exists
                        if (p.district) {
                            // Extract district number from property district field
                            const propertyDistrictMatch = p.district.match(/(\d+)/);
                            if (propertyDistrictMatch && propertyDistrictMatch[1]) {
                                districtMatch = pragueDistricts.includes(propertyDistrictMatch[1]);
                            }
                        }
                        
                        // Also check in the location field for district info
                        if (!districtMatch && p.location) {
                            const locationDistrictMatch = p.location.match(/prague\s*(\d+)/i);
                            if (locationDistrictMatch && locationDistrictMatch[1]) {
                                districtMatch = pragueDistricts.includes(locationDistrictMatch[1]);
                            }
                        }
                        
                        return districtMatch;
                    });
                    
                    debugLog(`After Prague district filter: ${results.length} properties remaining`);
                } else {
                    // If just "Prague" with no district, filter for any Prague property
                    results = results.filter(p => {
                        return (p.city && p.city.toLowerCase().includes('prague')) || 
                              (p.location && p.location.toLowerCase().includes('prague'));
                    });
                    debugLog(`After Prague city filter: ${results.length} properties remaining`);
                }
            } 
            // Handle non-Prague city search
            else if (criteria.location) {
                const locationKeywords = criteria.location.toLowerCase().split(/\s+/);
                results = results.filter(p => {
                    const propertyLocation = (p.location || "").toLowerCase();
                    const propertyCity = (p.city || "").toLowerCase();
                    
                    return locationKeywords.some(keyword => 
                        propertyLocation.includes(keyword) || 
                        propertyCity.includes(keyword)
                    );
                });
                debugLog(`After location filter: ${results.length} properties remaining`);
            }
            
            // Filter by property type
            if (criteria.type) {
                const typeKeywords = criteria.type.toLowerCase().split(/\s+/);
                results = results.filter(p => {
                    if (!p.type) return false;
                    const propertyType = p.type.toLowerCase();
                    return typeKeywords.some(keyword => propertyType.includes(keyword));
                });
                debugLog(`After type filter: ${results.length} properties remaining`);
            }
            
            // Enhanced size filtering logic
            const handleSizeFiltering = () => {
                // Handle size range queries (between X and Y)
                if (criteria.minSize && criteria.maxSize) {
                    const minSize = parseInt(criteria.minSize);
                    const maxSize = parseInt(criteria.maxSize);
                    
                    if (!isNaN(minSize) && !isNaN(maxSize)) {
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                        });
                        debugLog(`After size range filter (${minSize}-${maxSize}): ${results.length} properties remaining`);
                    }
                }
                // Handle approximate size with tolerance
                else if (criteria.size) {
                    const targetSize = parseInt(criteria.size);
                    if (!isNaN(targetSize)) {
                        const minSize = targetSize * 0.8;
                        const maxSize = targetSize * 1.2;
                        
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                        });
                        debugLog(`After approximate size filter (${criteria.size}): ${results.length} properties remaining`);
                    }
                }
                // Handle explicit max size only
                else if (criteria.maxSize) {
                    const maxSize = parseInt(criteria.maxSize);
                    if (!isNaN(maxSize)) {
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize <= maxSize;
                        });
                        debugLog(`After maxSize filter (${criteria.maxSize}): ${results.length} properties remaining`);
                    }
                }
                // Handle explicit min size only
                else if (criteria.minSize) {
                    const minSize = parseInt(criteria.minSize);
                    if (!isNaN(minSize)) {
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize;
                        });
                        debugLog(`After minSize filter (${criteria.minSize}): ${results.length} properties remaining`);
                    }
                }
            };
            
            handleSizeFiltering();
            
            // Handle "between X and Y" size queries from natural language
            if (!criteria.minSize && !criteria.maxSize && !criteria.size) {
                // Look for patterns like "between 400 and 500" or "from 400 to 500"
                const userQuery = conversationState.lastQuery.toLowerCase();
                const betweenMatch = userQuery.match(/between\s+(\d+)\s+and\s+(\d+)/i) || 
                                   userQuery.match(/from\s+(\d+)\s+to\s+(\d+)/i);
                
                if (betweenMatch) {
                    const minSize = parseInt(betweenMatch[1]);
                    const maxSize = parseInt(betweenMatch[2]);
                    
                    if (!isNaN(minSize) && !isNaN(maxSize)) {
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                        });
                        debugLog(`After "between ${minSize} and ${maxSize}" filter: ${results.length} properties remaining`);
                    }
                }
            }
            
            // Filter by price
            if (criteria.price) {
                results = results.filter(p => {
                    if (!p.price) return false;
                    return p.price.toLowerCase().includes(criteria.price.toLowerCase());
                });
                debugLog(`After price filter: ${results.length} properties remaining`);
            }
            
            // Filter by availability
            if (criteria.available) {
                const availableKeywords = criteria.available.toLowerCase().split(/\s+/);
                results = results.filter(p => {
                    if (!p.available) return false;
                    const propertyAvailable = p.available.toLowerCase();
                    return availableKeywords.some(keyword => propertyAvailable.includes(keyword));
                });
                debugLog(`After availability filter: ${results.length} properties remaining`);
            }
            
            // Exclude specific properties if needed
            if (criteria.excludeNames && criteria.excludeNames.length > 0) {
                results = results.filter(p => !criteria.excludeNames.includes(p.name));
                debugLog(`After exclusion filter: ${results.length} properties remaining`);
            }
            
            // If no results and we have size criteria, try with more relaxed constraints
            if (results.length === 0 && (criteria.size || criteria.minSize || criteria.maxSize)) {
                debugLog("No results with strict criteria, trying with relaxed constraints");
                
                // Save original results count for later
                const originalResultsCount = results.length;
                
                // Reset results
                results = [...properties];
                
                // Reapply non-size filters
                if (criteria.type) {
                    const typeKeywords = criteria.type.toLowerCase().split(/\s+/);
                    results = results.filter(p => {
                        if (!p.type) return false;
                        const propertyType = p.type.toLowerCase();
                        return typeKeywords.some(keyword => propertyType.includes(keyword));
                    });
                }
                
                // Reapply location filters (with special handling for Prague districts)
                if (criteria.location) {
                    if (criteria.location.toLowerCase().includes('prague')) {
                        // Handle Prague district special case again
                        const pragueDistrictMatch = criteria.location.match(/prague\s*(\d+)/i);
                        if (pragueDistrictMatch && pragueDistrictMatch[1]) {
                            // We found a Prague district, but let's be more lenient
                            results = results.filter(p => {
                                return (p.city && p.city.toLowerCase().includes('prague')) || 
                                      (p.location && p.location.toLowerCase().includes('prague'));
                            });
                        } else {
                            results = results.filter(p => {
                                return (p.city && p.city.toLowerCase().includes('prague')) || 
                                      (p.location && p.location.toLowerCase().includes('prague'));
                            });
                        }
                    } else {
                        const locationKeywords = criteria.location.toLowerCase().split(/\s+/);
                        results = results.filter(p => {
                            const propertyLocation = (p.location || "").toLowerCase();
                            const propertyCity = (p.city || "").toLowerCase();
                            const propertyDistrict = (p.district || "").toLowerCase();
                            
                            return locationKeywords.some(keyword => 
                                propertyLocation.includes(keyword) || 
                                propertyCity.includes(keyword) || 
                                propertyDistrict.includes(keyword)
                            );
                        });
                    }
                }
                
                // Apply more relaxed size constraints (40% instead of 20%)
                if (criteria.size) {
                    const targetSize = parseInt(criteria.size);
                    if (!isNaN(targetSize)) {
                        const minSize = targetSize * 0.6;
                        const maxSize = targetSize * 1.4;
                        
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                        });
                    }
                } 
                // Relax min/max ranges
                else {
                    if (criteria.maxSize) {
                        const maxSize = parseInt(criteria.maxSize) * 1.2; // 20% higher than requested max
                        if (!isNaN(maxSize)) {
                            results = results.filter(p => {
                                const propertySize = parseInt(p.size);
                                return !isNaN(propertySize) && propertySize <= maxSize;
                            });
                        }
                    }
                    
                    if (criteria.minSize) {
                        const minSize = parseInt(criteria.minSize) * 0.8; // 20% lower than requested min
                        if (!isNaN(minSize)) {
                            results = results.filter(p => {
                                const propertySize = parseInt(p.size);
                                return !isNaN(propertySize) && propertySize >= minSize;
                            });
                        }
                    }
                }
                
                debugLog(`After relaxed criteria: ${results.length} properties remaining (was ${originalResultsCount})`);
            }
            
            debugLog(`Final search results: ${results.length} properties`);
            return results;
        }

        // Helper function to generate property listing HTML
        function generatePropertyListingHTML(properties, offset = 0, limit = 5) {
            let html = "";
            
            // Get the relevant slice for pagination
            const propertiesToShow = properties.slice(offset, offset + limit);
            
            // Format property items
            propertiesToShow.forEach(property => {
                let propertyDetails = `<div class="property-item">
                    <div class="property-name">${property.name}</div>`;
                
                propertyDetails += `<div class="property-details">`;
                
                if (property.size) {
                    propertyDetails += `<span class="property-detail">${property.size} sqm</span>`;
                }
                
                if (property.type) {
                    propertyDetails += `<span class="property-detail">${property.type}</span>`;
                }
                
                if (property.price) {
                    propertyDetails += `<span class="property-detail">${property.price}</span>`;
                }
                
                if (property.floor) {
                    propertyDetails += `<span class="property-detail">${property.floor}</span>`;
                }
                
                // Use location if available, otherwise fallback to city and district
                if (property.location) {
                    propertyDetails += `<span class="property-detail">${property.location}</span>`;
                } else if (property.city) {
                    let locationText = property.city;
                    if (property.district) {
                        locationText += ` - ${property.district}`;
                    }
                    propertyDetails += `<span class="property-detail">${locationText}</span>`;
                }
                
                if (property.available) {
                    propertyDetails += `<span class="property-detail">Available: ${property.available}</span>`;
                }
                
                propertyDetails += `</div></div>`;
                
                html += propertyDetails;
            });
            
            return html;
        }

        // Updated local response generator with improved criteria handling
        function generateLocalResponse(userInput) {
            debugLog("Generating local response for:", userInput);
            userInput = userInput.toLowerCase();
            
            // Store for future reference
            conversationState.lastQuery = userInput;
            
            // Check if properties are loaded
            if (!propertiesLoaded || properties.length === 0) {
                debugLog("Properties not loaded, returning error message");
                return "I don't have access to our property listings at the moment. Please try again later or contact Integis directly for assistance.";
            }
            
            // Determine language for response (simple heuristic)
            const isCzechQuery = isCzech(userInput);
            debugLog("Language detection - isCzech:", isCzechQuery);
            
            // Check if this is a follow-up question
            const isFollowUp = isFollowUpQuestion(userInput);
            debugLog("Is follow-up question:", isFollowUp);
            
            // Create search criteria
            let criteria = {};
            
            // If follow-up, start with previous criteria
            if (isFollowUp && conversationState.currentSearchCriteria) {
                criteria = {...conversationState.currentSearchCriteria};
                debugLog("Using previous search criteria as base:", criteria);
                
                // For pagination requests, keep the same criteria but update offset
                if (/more|další|show more|ukázat více/i.test(userInput)) {
                    conversationState.offset += 5; // Show next 5 results
                    debugLog("Pagination request - updating offset to:", conversationState.offset);
                }
            } else {
                // Reset offset for new searches
                conversationState.offset = 0;
            }
            
            // Extract new criteria
            const newCriteria = extractSearchCriteria(userInput);
            
            // Merge with existing criteria, with new values taking precedence
            criteria = {...criteria, ...newCriteria};
            
            // For requests to "show all" - start fresh with just the core criteria
            if (/show all|share all|all properties|all units|všechny|všechny jednotky/i.test(userInput)) {
                // Keep only the most important criteria (type, location, size) and reset pagination
                const coreCriteria = {};
                if (criteria.type) coreCriteria.type = criteria.type;
                if (criteria.location) coreCriteria.location = criteria.location;
                if (criteria.size) coreCriteria.size = criteria.size;
                if (criteria.maxSize) coreCriteria.maxSize = criteria.maxSize;
                if (criteria.minSize) coreCriteria.minSize = criteria.minSize;
                
                criteria = coreCriteria;
                conversationState.offset = 0;
                debugLog("'Show all' request - using core criteria only:", criteria);
            }
            
            // IMPORTANT: Update the global conversation state with the new criteria
            conversationState.currentSearchCriteria = {...criteria};
            debugLog("Updated conversation state with new criteria:", conversationState.currentSearchCriteria);
            
            // Search for matching properties with enhanced search function
            let matchedProperties = enhancedSearchProperties(criteria);
            
            // Store the properties we've shown for follow-up questions
            if (matchedProperties.length > 0) {
                const propertiesToShow = matchedProperties.slice(
                    conversationState.offset, 
                    conversationState.offset + 5
                );
                
                // Update last shown properties
                conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
                debugLog("Updated last shown properties:", conversationState.lastShownProperties);
            }
            
            // Generate response
            if (matchedProperties.length > 0) {
                debugLog(`Generating response with ${matchedProperties.length} matching properties (offset: ${conversationState.offset})`);
                
                let response = "";
                
                if (isFollowUp && /more|další|show more|ukázat více/i.test(userInput) && conversationState.offset > 0) {
                    response = isCzechQuery 
                        ? `Ano, zde jsou další nemovitosti, které splňují vaše kritéria:<br><br>`
                        : `Yes, here are more properties that match your criteria:<br><br>`;
                } else if (isFollowUp) {
                    if (criteria.location && criteria.type) {
                        if (criteria.minSize && criteria.maxSize) {
                            response = isCzechQuery 
                                ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location} o velikosti mezi ${criteria.minSize} a ${criteria.maxSize} m²:<br><br>`
                                : `I found these ${criteria.type} spaces in ${criteria.location} with a size between ${criteria.minSize} and ${criteria.maxSize} sqm:<br><br>`;
                        } else if (criteria.size) {
                            response = isCzechQuery 
                                ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location} o velikosti kolem ${criteria.size} m²:<br><br>`
                                : `I found these ${criteria.type} spaces in ${criteria.location} with a size around ${criteria.size} sqm:<br><br>`;
                        } else {
                            response = isCzechQuery 
                                ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location}:<br><br>`
                                : `I found these ${criteria.type} spaces in ${criteria.location}:<br><br>`;
                        }
                    } else {
                        response = isCzechQuery 
                            ? `Na základě upřesněných kritérií jsem našel tyto nemovitosti:<br><br>`
                            : `Based on your refined criteria, I found these properties:<br><br>`;
                    }
                } else {
                    response = isCzechQuery 
                        ? `Na základě vašeho dotazu jsem našel tyto nemovitosti, které by vás mohly zajímat:<br><br>`
                        : `Based on your query, I found these properties that might interest you:<br><br>`;
                }
                
                // Get the relevant slice for pagination
                const propertiesToShow = matchedProperties.slice(
                    conversationState.offset, 
                    conversationState.offset + 5
                );
                
                // If no properties to show at current offset but we have matches
                if (propertiesToShow.length === 0 && matchedProperties.length > 0) {
                    // Reset offset to 0 and show the first page
                    conversationState.offset = 0;
                    const propertiesToShow = matchedProperties.slice(0, 5);
                    
                    response = isCzechQuery 
                        ? `Došli jsme na konec výsledků. Zde jsou znovu první nemovitosti:<br><br>`
                        : `We've reached the end of the results. Here are the first properties again:<br><br>`;
                        
                    conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
                }
                
                // Add property listings HTML
                response += generatePropertyListingHTML(matchedProperties, conversationState.offset, 5);
                
                // Add pagination information
                const remainingCount = matchedProperties.length - (conversationState.offset + propertiesToShow.length);
                if (remainingCount > 0) {
                    response += isCzechQuery
                        ? `<br>Zobrazuji ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí. Napište "více" pro zobrazení dalších.`
                        : `<br>Showing ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} of ${matchedProperties.length} matching properties. Type "more" to see more.`;
                } else {
                    response += isCzechQuery
                        ? `<br>Zobrazuji ${propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.`
                        : `<br>Showing ${propertiesToShow.length} of ${matchedProperties.length} matching properties.`;
                }
                
                // Add follow-up prompt
                response += isCzechQuery
                    ? `<br><br>Přejete si více informací o některé z těchto nemovitostí nebo chcete upřesnit vyhledávání?`
                    : `<br><br>Would you like more details about any of these properties or would you like to refine your search?`;
                    
                return response;
            } else {
                debugLog("No matching properties found");
                
                let noMatchResponse = "";
                
                if (isFollowUp) {
                    noMatchResponse = isCzechQuery
                        ? `Bohužel jsem nenašel žádné nemovitosti, které by odpovídaly těmto upřesněným požadavkům. Možná zkuste jiné parametry?`
                        : `I couldn't find any properties matching these refined criteria. Perhaps try different parameters?`;
                        
                    // Suggest alternatives by relaxing constraints
                    if (criteria.location && criteria.type) {
                        // Try without size constraint
                        const withoutSizeSearch = {...criteria};
                        delete withoutSizeSearch.size;
                        delete withoutSizeSearch.maxSize;
                        delete withoutSizeSearch.minSize;
                        
                        const sizeAlternatives = enhancedSearchProperties(withoutSizeSearch);
                        
                        if (sizeAlternatives.length > 0) {
                            noMatchResponse += isCzechQuery
                                ? `<br><br>Našel jsem však ${sizeAlternatives.length} ${criteria.type} nemovitostí v lokalitě ${criteria.location} bez omezení velikosti. Přejete si je zobrazit?`
                                : `<br><br>However, I found ${sizeAlternatives.length} ${criteria.type} properties in ${criteria.location} without size restrictions. Would you like to see them?`;
                        }
                    }
                } else {
                    noMatchResponse = isCzechQuery
                        ? `Bohužel jsem nenašel přesné shody pro vaše kritéria z našich ${properties.length} nemovitostí. Můžete zkusit obecnější vyhledávání? Například se můžete zeptat na "kancelářské prostory v Praze" nebo "obchodní prostory kolem 800 sqm".`
                        : `I couldn't find exact matches for your criteria from our ${properties.length} properties. Could you try a more general search? For example, you can ask about "office space in Prague" or "retail space around 800 sqm".`;
                }
                
                return noMatchResponse;
            }
        }

        // New function to call Gemini API specifically for people to sqm conversion
        async function callGeminiAPIForPeopleConversion(peopleCount, spaceType = "office") {
            debugLog("Calling Gemini API to convert people count to sqm");
            
            try {
                // Format the prompt for Gemini
                const conversionPrompt = `
                You are a commercial real estate expert. Convert number of people to square meters needed for ${spaceType} space.
                Be realistic and follow these guidelines:
                - For office space: typically 8-12 sqm per person for standard offices, 15-20 sqm for executive space
                - For retail: depends on type but generally 15-40 sqm per staff member
                - For industrial: typically 25-50 sqm per worker depending on operations
                
                For ${peopleCount} people in a ${spaceType} space, provide the minimum and maximum sqm required.
                
                Format your response EXACTLY as a JSON object with minSize and maxSize properties as numbers only:
                {"minSize": X, "maxSize": Y}
                
                Do not include any explanation, ONLY return the JSON object.
                `;
                
                // Call the Gemini API
                const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [
                            {
                                role: "user",
                                parts: [{ text: conversionPrompt }]
                            }
                        ],
                        generationConfig: {
                            temperature: 0.2,  // Lower temperature for more deterministic output
                            maxOutputTokens: 100
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Extract the generated text
                if (result.candidates && result.candidates.length > 0 && 
                    result.candidates[0].content && result.candidates[0].content.parts && 
                    result.candidates[0].content.parts.length > 0) {
                    
                    const generatedText = result.candidates[0].content.parts[0].text.trim();
                    debugLog("Received conversion response:", generatedText);
                    
                    // Parse the JSON response
                    try {
                        const conversion = JSON.parse(generatedText);
                        if (conversion.minSize && conversion.maxSize) {
                            return {
                                minSize: Math.round(conversion.minSize),
                                maxSize: Math.round(conversion.maxSize)
                            };
                        }
                    } catch (parseError) {
                        debugLog("Error parsing conversion JSON:", parseError.message);
                        // Try to extract numbers from the text if JSON parsing fails
                        const numbers = generatedText.match(/\d+/g);
                        if (numbers && numbers.length >= 2) {
                            return {
                                minSize: Math.round(parseInt(numbers[0])),
                                maxSize: Math.round(parseInt(numbers[1]))
                            };
                        }
                    }
                }
                
                throw new Error("Could not extract size conversion from Gemini response");
            } catch (error) {
                debugLog("Error in people to sqm conversion:", error.message);
                // Provide a fallback conversion based on standard metrics
                const fallbackSizes = {
                    "office": { min: Math.round(peopleCount * 8), max: Math.round(peopleCount * 12) },
                    "retail": { min: Math.round(peopleCount * 15), max: Math.round(peopleCount * 40) },
                    "industrial": { min: Math.round(peopleCount * 25), max: Math.round(peopleCount * 50) }
                };
                
                const fallback = fallbackSizes[spaceType] || fallbackSizes.office;
                debugLog("Using fallback conversion:", fallback);
                
                return {
                    minSize: fallback.min,
                    maxSize: fallback.max
                };
            }
        }

        // Call the Gemini API
        async function callGeminiAPI(userInput) {
            debugLog("Starting Gemini API call for input:", userInput);
            
            // Check if properties are loaded
            if (!propertiesLoaded || properties.length === 0) {
                debugLog("Properties not loaded, returning error message");
                return "I don't have access to our property listings at the moment. Please try again later or ask general questions about commercial real estate.";
            }
// Add these new functions after your existing JavaScript code

// Function to handle button clicks
function handleSuggestionClick(suggestion) {
    // Add the suggestion text to the input field
    document.getElementById('user-input').value = suggestion;
    
    // Submit the form (trigger sendMessage)
    sendMessage();
}

// Function to handle refinement button clicks
function handleRefinementClick(refinementType, value) {
    // Get current criteria
    let criteria = {...conversationState.currentSearchCriteria} || {};
    
    // Update criteria based on refinement type
    switch (refinementType) {
        case 'minSize':
            criteria.minSize = value;
            break;
        case 'maxSize':
            criteria.maxSize = value;
            break;
        case 'type':
            criteria.type = value;
            break;
        case 'location':
            criteria.location = value;
            break;
        case 'available':
            criteria.available = value;
            break;
        case 'clearSize':
            delete criteria.size;
            delete criteria.minSize;
            delete criteria.maxSize;
            break;
        default:
            break;
    }
    
    // Update conversation state
    conversationState.currentSearchCriteria = criteria;
    
    // Generate a message to show what we're doing
    const message = `Updating search: ${refinementType} = ${value}`;
    debugLog(message);
    
    // Add user message (showing what refinement was chosen)
    const refinementText = isCzech(document.getElementById('user-input').value) 
        ? `Upřesnit vyhledávání: ${getReadableCriteria(refinementType, value, true)}`
        : `Refine search: ${getReadableCriteria(refinementType, value, false)}`;
    
    addMessage(refinementText, 'user');
    conversationHistory.push({role: "user", content: refinementText});
    
    // Trigger a new search with updated criteria
    const searchResults = enhancedSearchProperties(criteria);
    
    // Generate and show results
    displaySearchResults(searchResults, criteria);
}

// Function to get readable criteria text
function getReadableCriteria(type, value, isCzechLanguage) {
    if (isCzechLanguage) {
        switch (type) {
            case 'minSize': return `Minimální velikost: ${value} m²`;
            case 'maxSize': return `Maximální velikost: ${value} m²`;
            case 'type': 
                if (value === 'office') return 'Typ: Kanceláře';
                if (value === 'retail') return 'Typ: Obchodní prostory';
                if (value === 'industrial') return 'Typ: Průmyslové prostory';
                return `Typ: ${value}`;
            case 'location': return `Lokalita: ${value}`;
            case 'available': 
                if (value === 'now') return 'Dostupnost: Ihned';
                return `Dostupnost: ${value}`;
            case 'clearSize': return 'Odstranit omezení velikosti';
            default: return `${type}: ${value}`;
        }
    } else {
        switch (type) {
            case 'minSize': return `Minimum size: ${value} sqm`;
            case 'maxSize': return `Maximum size: ${value} sqm`;
            case 'type': return `Type: ${value}`;
            case 'location': return `Location: ${value}`;
            case 'available': 
                if (value === 'now') return 'Availability: Immediate';
                return `Availability: ${value}`;
            case 'clearSize': return 'Clear size restrictions';
            default: return `${type}: ${value}`;
        }
    }
}

// Function to display search results
function displaySearchResults(matchedProperties, criteria) {
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Short timeout to show the typing indicator before showing results
    setTimeout(() => {
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Reset pagination offset
        conversationState.offset = 0;
        
        // Check if we have results
        if (matchedProperties.length > 0) {
            // Generate introduction text
            const isCzechQuery = isCzech(document.getElementById('user-input').value);
            let response = isCzechQuery 
                ? `Našel jsem ${matchedProperties.length} nemovitostí s těmito parametry:<br><br>`
                : `I found ${matchedProperties.length} properties with these parameters:<br><br>`;
            
            // Add active filters section
            response += generateActiveFiltersHTML(criteria, isCzechQuery);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, 0, 5);
            
            // Add pagination (now with a button instead of text)
            if (matchedProperties.length > 5) {
                response += isCzechQuery
                    ? `<br>Zobrazuji 1-5 z ${matchedProperties.length} nalezených nemovitostí.<br>`
                    : `<br>Showing 1-5 of ${matchedProperties.length} matching properties.<br>`;
                
                // Add "Show More" button
                response += `<div class="action-button-container">
                    <button class="action-button" onclick="handleShowMore()">${isCzechQuery ? 'Zobrazit další' : 'Show More'}</button>
                </div>`;
            } else {
                response += isCzechQuery
                    ? `<br>Zobrazuji ${matchedProperties.length} z ${matchedProperties.length} nalezených nemovitostí.`
                    : `<br>Showing ${matchedProperties.length} of ${matchedProperties.length} matching properties.`;
            }
            
            // Add refinement buttons
            response += generateRefinementButtonsHTML(criteria, isCzechQuery);
            
            // Add suggestion buttons for common follow-ups
            response += generateSuggestionButtonsHTML(criteria, isCzechQuery);
            
            // Update last shown properties
            conversationState.lastShownProperties = matchedProperties.slice(0, 5).map(p => p.name);
            
            // Display the response
            addMessage(response, 'bot');
            conversationHistory.push({role: "assistant", content: response});
        } else {
            // No results found
            const isCzechQuery = isCzech(document.getElementById('user-input').value);
            let noResultsResponse = isCzechQuery
                ? `Bohužel jsem nenašel žádné nemovitosti odpovídající těmto kritériím.<br><br>`
                : `I couldn't find any properties matching these criteria.<br><br>`;
            
            // Add active filters section
            noResultsResponse += generateActiveFiltersHTML(criteria, isCzechQuery);
            
            // Add suggestion to modify search
            noResultsResponse += isCzechQuery
                ? `<p>Zkuste upravit vyhledávací kritéria pro více výsledků:</p>`
                : `<p>Try modifying your search criteria for more results:</p>`;
            
            // Add buttons to relax search criteria
            noResultsResponse += `<div class="suggestion-buttons">`;
            
            if (criteria.minSize || criteria.maxSize || criteria.size) {
                noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('clearSize', '')">${isCzechQuery ? 'Odstranit omezení velikosti' : 'Remove size restrictions'}</button>`;
            }
            
            // More buttons to try different locations or types
            if (criteria.type) {
                const types = ['office', 'retail', 'industrial'].filter(t => t !== criteria.type);
                types.forEach(type => {
                    const typeLabel = type === 'office' 
                        ? (isCzechQuery ? 'Kanceláře' : 'Office')
                        : type === 'retail' 
                            ? (isCzechQuery ? 'Obchodní prostory' : 'Retail')
                            : (isCzechQuery ? 'Průmyslové prostory' : 'Industrial');
                    
                    noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('type', '${type}')">${typeLabel}</button>`;
                });
            }
            
            if (criteria.location) {
                const locations = ['Prague', 'Brno', 'Ostrava'].filter(l => !criteria.location.includes(l));
                locations.forEach(location => {
                    noResultsResponse += `<button class="suggestion-button" onclick="handleRefinementClick('location', '${location}')">${location}</button>`;
                });
            }
            
            noResultsResponse += `</div>`;
            
            // Display the response
            addMessage(noResultsResponse, 'bot');
            conversationHistory.push({role: "assistant", content: noResultsResponse});
        }
    }, 500);
}

// Function to generate active filters HTML
function generateActiveFiltersHTML(criteria, isCzechQuery) {
    let filtersHTML = '';
    const hasFilters = Object.keys(criteria).length > 0 && 
                      (criteria.type || criteria.location || criteria.minSize || 
                       criteria.maxSize || criteria.size || criteria.available);
    
    if (hasFilters) {
        filtersHTML += `<div class="active-filters">
            <div style="width:100%; margin-bottom:5px; font-size:12px; color:#666;">
                ${isCzechQuery ? 'Aktivní filtry:' : 'Active filters:'}
            </div>`;
        
        if (criteria.type) {
            const typeLabel = criteria.type === 'office' 
                ? (isCzechQuery ? 'Kanceláře' : 'Office')
                : criteria.type === 'retail' 
                    ? (isCzechQuery ? 'Obchodní prostory' : 'Retail')
                    : (isCzechQuery ? 'Průmyslové prostory' : 'Industrial');
            
            filtersHTML += `<div class="filter-tag">${typeLabel}</div>`;
        }
        
        if (criteria.location) {
            filtersHTML += `<div class="filter-tag">${criteria.location}</div>`;
        }
        
        if (criteria.size) {
            filtersHTML += `<div class="filter-tag">${isCzechQuery ? 'Přibližně' : 'Around'} ${criteria.size} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        } else if (criteria.minSize && criteria.maxSize) {
            filtersHTML += `<div class="filter-tag">${criteria.minSize}-${criteria.maxSize} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        } else if (criteria.minSize) {
            filtersHTML += `<div class="filter-tag">${isCzechQuery ? 'Min' : 'Min'} ${criteria.minSize} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        } else if (criteria.maxSize) {
            filtersHTML += `<div class="filter-tag">${isCzechQuery ? 'Max' : 'Max'} ${criteria.maxSize} ${isCzechQuery ? 'm²' : 'sqm'}</div>`;
        }
        
        if (criteria.available) {
            const availLabel = criteria.available === 'now'
                ? (isCzechQuery ? 'Dostupné ihned' : 'Available now')
                : criteria.available;
            
            filtersHTML += `<div class="filter-tag">${availLabel}</div>`;
        }
        
        filtersHTML += `</div>`;
    }
    
    return filtersHTML;
}

// Function to generate refinement buttons HTML
function generateRefinementButtonsHTML(criteria, isCzechQuery) {
    let buttonsHTML = `<div class="refinement-buttons">
        <div style="width:100%; margin-bottom:5px; font-size:12px; color:#666;">
            ${isCzechQuery ? 'Upřesnit vyhledávání:' : 'Refine your search:'}
        </div>`;
    
    // Size refinements
    if (!criteria.minSize && !criteria.maxSize) {
        // Add some standard size options if no size filter applied yet
        const sizes = [
            { min: 100, max: 300 },
            { min: 300, max: 500 },
            { min: 500, max: 1000 },
            { min: 1000, max: 2000 }
        ];
        
        sizes.forEach(size => {
            buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('minSize', ${size.min}); handleRefinementClick('maxSize', ${size.max});">
                ${size.min}-${size.max} ${isCzechQuery ? 'm²' : 'sqm'}
            </button>`;
        });
    } else {
        // Option to clear size filter if one is applied
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('clearSize', '')">
            ${isCzechQuery ? 'Odstranit omezení velikosti' : 'Clear size filter'}
        </button>`;
    }
    
    // Type refinements (if not already specified)
    if (!criteria.type) {
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('type', 'office')">
            ${isCzechQuery ? 'Kanceláře' : 'Office'}
        </button>
        <button class="refinement-button" onclick="handleRefinementClick('type', 'retail')">
            ${isCzechQuery ? 'Obchodní prostory' : 'Retail'}
        </button>
        <button class="refinement-button" onclick="handleRefinementClick('type', 'industrial')">
            ${isCzechQuery ? 'Průmyslové prostory' : 'Industrial'}
        </button>`;
    }
    
    // Location refinements (if not already specified)
    if (!criteria.location) {
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('location', 'Prague')">Prague</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Brno')">Brno</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Ostrava')">Ostrava</button>`;
    } else if (criteria.location === 'Prague' && !criteria.location.includes('Prague ')) {
        // Add Prague district options
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 1')">Prague 1</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 4')">Prague 4</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 5')">Prague 5</button>
        <button class="refinement-button" onclick="handleRefinementClick('location', 'Prague 8')">Prague 8</button>`;
    }
    
    // Availability refinement
    if (!criteria.available) {
        buttonsHTML += `<button class="refinement-button" onclick="handleRefinementClick('available', 'now')">
            ${isCzechQuery ? 'Dostupné ihned' : 'Available now'}
        </button>`;
    }
    
    buttonsHTML += `</div>`;
    
    return buttonsHTML;
}

// Function to generate suggestion buttons HTML
function generateSuggestionButtonsHTML(criteria, isCzechQuery) {
    let buttonsHTML = `<div class="suggestion-buttons">
        <div style="width:100%; margin-bottom:5px; font-size:12px; color:#666;">
            ${isCzechQuery ? 'Můžete se také zeptat:' : 'You can also ask:'}
        </div>`;
    
    // Generate relevant suggestions based on current criteria
    if (criteria.type && criteria.location) {
        // They already specified type and location, suggest size or specifics
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Kolik stojí ' + criteria.type + ' v ' + criteria.location + '?' : 'How much does ' + criteria.type + ' space cost in ' + criteria.location + '?'}')">
            ${isCzechQuery ? 'Kolik stojí ' + criteria.type + ' v ' + criteria.location + '?' : 'How much does ' + criteria.type + ' space cost in ' + criteria.location + '?'}
        </button>`;
        
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Máte nějaké ' + criteria.type + ' s parkováním v ' + criteria.location + '?' : 'Do you have any ' + criteria.type + ' space with parking in ' + criteria.location + '?'}')">
            ${isCzechQuery ? 'S parkováním?' : 'With parking?'}
        </button>`;
    } else if (criteria.type) {
        // They specified type but not location
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Kde máte nejlevnější ' + criteria.type + '?' : 'Where do you have the cheapest ' + criteria.type + ' space?'}')">
            ${isCzechQuery ? 'Kde máte nejlevnější ' + criteria.type + '?' : 'Where are your cheapest ' + criteria.type + ' spaces?'}
        </button>`;
        
        // Suggest popular locations
        ['Prague', 'Brno', 'Ostrava'].forEach(location => {
            buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? criteria.type + ' v ' + location : criteria.type + ' in ' + location}')">
                ${isCzechQuery ? criteria.type + ' v ' + location : criteria.type + ' in ' + location}
            </button>`;
        });
    } else if (criteria.location) {
        // They specified location but not type
        buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? 'Jaké typy nemovitostí máte v ' + criteria.location + '?' : 'What types of properties do you have in ' + criteria.location + '?'}')">
            ${isCzechQuery ? 'Jaké typy nemovitostí máte v ' + criteria.location + '?' : 'What types of properties in ' + criteria.location + '?'}
        </button>`;
        
        // Suggest different property types
        const types = [
            { value: 'office', labelCz: 'Kanceláře', labelEn: 'Office space' },
            { value: 'retail', labelCz: 'Obchodní prostory', labelEn: 'Retail space' },
            { value: 'industrial', labelCz: 'Průmyslové prostory', labelEn: 'Industrial space' }
        ];
        
        types.forEach(type => {
            buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${isCzechQuery ? type.labelCz + ' v ' + criteria.location : type.labelEn + ' in ' + criteria.location}')">
                ${isCzechQuery ? type.labelCz + ' v ' + criteria.location : type.labelEn + ' in ' + criteria.location}
            </button>`;
        });
    } else {
        // No specific criteria yet, suggest common starting points
        const suggestions = isCzechQuery 
            ? ['Kancelářské prostory v Praze', 'Obchodní prostory v centru', 'Průmyslové prostory větší než 1000 m²', 'Prostory pro 50 lidí'] 
            : ['Office space in Prague', 'Retail space in city center', 'Industrial space larger than 1000 sqm', 'Space for 50 people'];
        
        suggestions.forEach(suggestion => {
            buttonsHTML += `<button class="suggestion-button" onclick="handleSuggestionClick('${suggestion}')">
                ${suggestion}
            </button>`;
        });
    }
    
    buttonsHTML += `</div>`;
    
    return buttonsHTML;
}

// Function to handle "Show More" button click
function handleShowMore() {
    // Add user message
    const moreText = isCzech(document.getElementById('user-input').value) ? "Zobrazit další" : "Show more";
    addMessage(moreText, 'user');
    conversationHistory.push({role: "user", content: moreText});
    
    // Increase offset
    conversationState.offset += 5;
    
    // Get current criteria
    const criteria = {...conversationState.currentSearchCriteria} || {};
    
    // Search for matching properties
    const matchedProperties = enhancedSearchProperties(criteria);
    
    // Show typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.textContent = 'Typing...';
    typingIndicator.id = 'typing-indicator';
    document.getElementById('messages').appendChild(typingIndicator);
    
    // Short timeout to show the typing indicator before showing results
    setTimeout(() => {
        if (document.getElementById('typing-indicator')) {
            document.getElementById('typing-indicator').remove();
        }
        
        // Generate response
        const isCzechQuery = isCzech(document.getElementById('user-input').value);
        let response = isCzechQuery 
            ? `Ano, zde jsou další nemovitosti, které splňují vaše kritéria:<br><br>`
            : `Yes, here are more properties that match your criteria:<br><br>`;
        
        // Get the relevant slice for pagination
        const start = conversationState.offset;
        const end = conversationState.offset + 5;
        const propertiesToShow = matchedProperties.slice(start, end);
        
        // If no properties to show at current offset but we have matches, wrap around
        if (propertiesToShow.length === 0 && matchedProperties.length > 0) {
            // Reset offset to 0 and show the first page
            conversationState.offset = 0;
            
            response = isCzechQuery 
                ? `Došli jsme na konec výsledků. Zde jsou znovu první nemovitosti:<br><br>`
                : `We've reached the end of the results. Here are the first properties again:<br><br>`;
                
            // Update properties to show
            const firstPageProperties = matchedProperties.slice(0, 5);
            // Update last shown properties
            conversationState.lastShownProperties = firstPageProperties.map(p => p.name);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, 0, 5);
        } else {
            // Update last shown properties
            conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
            
            // Add property listings
            response += generatePropertyListingHTML(matchedProperties, conversationState.offset, 5);
        }
        
        // Add pagination information with Show More button
        const nextBatch = conversationState.offset + 5;
        const remaining = matchedProperties.length - nextBatch;
        
        if (remainingCount > 0) {
            response += isCzechQuery
                ? `<br>Zobrazuji ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.<br>`
                : `<br>Showing ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} of ${matchedProperties.length} matching properties.<br>`;
            
            // Add "Show More" button
            response += `<div class="action-button-container">
                <button class="action-button" onclick="handleShowMore()">${isCzechQuery ? 'Zobrazit další' : 'Show More'}</button>
            </div>`;
        } else {
            response += isCzechQuery
                ? `<br>Zobrazuji ${propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.`
                : `<br>Showing ${propertiesToShow.length} of ${matchedProperties.length} matching properties.`;
}

        // Add active filters display
        response += generateActiveFiltersHTML(criteria, isCzechQuery);

        // Add refinement buttons
        response += generateRefinementButtonsHTML(criteria, isCzechQuery);

        // Add suggestion buttons
        response += generateSuggestionButtonsHTML(criteria, isCzechQuery);
        
        // Add suggestion buttons
        response += generateSuggestionButtonsHTML(criteria, isCzechQuery);
        
        // Display the response
        addMessage(response, 'bot');
        conversationHistory.push({role: "assistant", content: response});
    }, 500);

    // Function to start a progressive conversation
function startProgressiveConversation() {
    const steps = [
        { question: 'What type of commercial property are you looking for?', field: 'type' },
        { question: 'Where would you like the property to be located?', field: 'location' },
        { question: 'What size range are you interested in (in sqm)?', field: 'size' },
        { question: 'When do you need the space to be available?', field: 'available' }
    ];
    
    // Store the conversation flow in the state
    conversationState.progressiveFlow = {
        steps: steps,
        currentStep: 0,
        answers: {}
    };
    
    // Display the first question
    const firstQuestion = steps[0].question;
    
    // Add contextual buttons for the first question
    let buttons = '';
    
    if (steps[0].field === 'type') {
        buttons = `<div class="suggestion-buttons">
            <button class="suggestion-button" onclick="handleProgressiveAnswer('office', 'Office space')">Office space</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('retail', 'Retail space')">Retail space</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('industrial', 'Industrial space')">Industrial space</button>
        </div>`;
    }
    
    // Display the first question with step indicator
    let message = `<div class="step-indicator">
        <div class="step active"></div>
        <div class="step"></div>
        <div class="step"></div>
        <div class="step"></div>
    </div>
    <p>${firstQuestion}</p>
    ${buttons}`;
    
    addMessage(message, 'bot');
    conversationHistory.push({role: "assistant", content: firstQuestion});
}

// Function to handle progressive answers
function handleProgressiveAnswer(value, displayText) {
    // First, display the user's answer
    addMessage(displayText, 'user');
    conversationHistory.push({role: "user", content: displayText});
    
    // Get the current flow
    const flow = conversationState.progressiveFlow;
    if (!flow) return;
    
    // Save the answer
    const currentField = flow.steps[flow.currentStep].field;
    flow.answers[currentField] = value;
    
    // Move to the next step
    flow.currentStep++;
    
    // Check if we've completed all steps
    if (flow.currentStep >= flow.steps.length) {
        // We're done, perform the search with collected criteria
        const criteria = {
            type: flow.answers.type,
            location: flow.answers.location
        };
        
        // Handle size (could be a range or single value)
        if (flow.answers.size && flow.answers.size.includes('-')) {
            const [min, max] = flow.answers.size.split('-');
            criteria.minSize = min.trim();
            criteria.maxSize = max.trim();
        } else if (flow.answers.size) {
            criteria.size = flow.answers.size;
        }
        
        // Handle availability
        if (flow.answers.available) {
            criteria.available = flow.answers.available;
        }
        
        // Update conversation state
        conversationState.currentSearchCriteria = criteria;
        
        // Show typing indicator
        const typingIndicator = document.createElement('div');
        typingIndicator.className = 'typing-indicator';
        typingIndicator.textContent = 'Typing...';
        typingIndicator.id = 'typing-indicator';
        document.getElementById('messages').appendChild(typingIndicator);
        
        // Short timeout to show the typing indicator
        setTimeout(() => {
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            // Reset the progressive flow
            delete conversationState.progressiveFlow;
            
            // Search for matching properties
            const matchedProperties = enhancedSearchProperties(criteria);
            
            // Display results
            displaySearchResults(matchedProperties, criteria);
        }, 1000);
        
        return;
    }
    
    // Display the next question
    const nextQuestion = flow.steps[flow.currentStep].question;
    let buttons = '';
    
    // Add contextual buttons based on the current field
    if (flow.steps[flow.currentStep].field === 'location') {
        buttons = `<div class="suggestion-buttons">
            <button class="suggestion-button" onclick="handleProgressiveAnswer('Prague', 'Prague')">Prague</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('Brno', 'Brno')">Brno</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('Ostrava', 'Ostrava')">Ostrava</button>
        </div>`;
    } else if (flow.steps[flow.currentStep].field === 'size') {
        buttons = `<div class="suggestion-buttons">
            <button class="suggestion-button" onclick="handleProgressiveAnswer('100-300', '100-300 sqm')">100-300 sqm</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('300-500', '300-500 sqm')">300-500 sqm</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('500-1000', '500-1000 sqm')">500-1000 sqm</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('1000-2000', '1000-2000 sqm')">1000-2000 sqm</button>
        </div>`;
    } else if (flow.steps[flow.currentStep].field === 'available') {
        buttons = `<div class="suggestion-buttons">
            <button class="suggestion-button" onclick="handleProgressiveAnswer('now', 'Immediately')">Immediately</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('Q3 2025', 'Q3 2025')">Q3 2025</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('Q4 2025', 'Q4 2025')">Q4 2025</button>
            <button class="suggestion-button" onclick="handleProgressiveAnswer('Any', 'Any time')">Any time</button>
        </div>`;
    }
    
    // Update step indicator
    let stepIndicator = '<div class="step-indicator">';
    for (let i = 0; i < flow.steps.length; i++) {
        if (i < flow.currentStep) {
            stepIndicator += '<div class="step" style="background-color: #4caf50;"></div>'; // Completed steps
        } else if (i === flow.currentStep) {
            stepIndicator += '<div class="step active"></div>'; // Current step
        } else {
            stepIndicator += '<div class="step"></div>'; // Future steps
        }
    }
    stepIndicator += '</div>';
    
    // Display the next question
    let message = `${stepIndicator}
    <p>${nextQuestion}</p>
    ${buttons}`;
    
    addMessage(message, 'bot');
    conversationHistory.push({role: "assistant", content: nextQuestion});
}

// Add this to window object
window.startProgressiveConversation = startProgressiveConversation;
window.handleProgressiveAnswer = handleProgressiveAnswer;
}            
            // Format properties as text for the prompt (limited to keep size manageable)
            let propertiesText = "";
            properties.slice(0, 20).forEach(property => { // Reduced to 20 properties
                let detailsText = `- ${property.name}: ${property.size} sqm ${property.type || ""}`;
                
                if (property.price) {
                    detailsText += `, ${property.price}`;
                }
                
                if (property.location) {
                    detailsText += ` in ${property.location}`;
                } else if (property.city) {
                    detailsText += ` in ${property.city}`;
                    if (property.district) {
                        detailsText += ` - ${property.district}`;
                    }
                }
                
                if (property.available) {
                    detailsText += `, available: ${property.available}`;
                }
                
                detailsText += "\n";
                propertiesText += detailsText;
            });

            // Previous conversation messages for context
            const previousMessages = [];
            for (let i = 0; i < conversationHistory.length; i++) {
                const message = conversationHistory[i];
                previousMessages.push({
                    role: message.role,
                    parts: [{ text: message.content }]
                });
            }

            // Create the system prompt
            const systemPrompt = `You are a professional commercial real estate assistant for Integis. Your job is to help clients find the perfect office, retail, or industrial space based on their needs. Be concise, professional, and helpful.

IMPORTANT INSTRUCTIONS:
1. ALWAYS maintain conversation context throughout the entire chat session
2. Remember previous searches and parameters
3. When user asks follow-up questions, add to their previous search criteria instead of replacing it
4. If they ask for "offices in Ostrava under 100 sqm" and then later ask "what about in Prague?", keep the type (office) and size (under 100 sqm) but change the location
5. When presenting properties, format them in an easy-to-read way with HTML (use <div>, <span> tags with appropriate classes)
6. If you don't have information, be honest and offer to help in other ways
7. Always respond in the same language as the user (Czech or English)

CONVERSATION CONTEXT:
Current Search Criteria: ${JSON.stringify(conversationState.currentSearchCriteria || {})}
Last Shown Properties: ${JSON.stringify(conversationState.lastShownProperties || [])}

AVAILABLE PROPERTIES:
${propertiesText}`;

            try {
                // Format the request for Gemini API
                const requestData = {
                    contents: [
                        {
                            role: "user",
                            parts: [{ text: systemPrompt }]
                        },
                        {
                            role: "model",
                            parts: [{ text: "I understand. I am a professional commercial real estate assistant for Integis. I'll help clients find properties based on their needs while maintaining conversation context and following all your instructions." }]
                        },
                        {
                            role: "user",
                            parts: [{ text: userInput }]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 800,
                    }
                };

                // Add previous conversation messages if available
                if (previousMessages.length > 1) { // Skip welcome message
                    requestData.contents = [
                        {
                            role: "user",
                            parts: [{ text: systemPrompt }]
                        },
                        {
                            role: "model",
                            parts: [{ text: "I understand. I am a professional commercial real estate assistant for Integis. I'll help clients find properties based on their needs while maintaining conversation context and following all your instructions." }]
                        },
                        ...previousMessages.slice(1), // Add all previous messages except welcome
                        {
                            role: "user",
                            parts: [{ text: userInput }]
                        }
                    ];
                }

                // Call the Gemini API
                debugLog("Sending API request to Gemini API");
                const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                debugLog("Gemini API Response Status:", response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    debugLog("Gemini API Error:", errorText);
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                debugLog("Gemini API result structure:", Object.keys(result));

                // Extract the generated text
                if (result && result.candidates && result.candidates.length > 0 && 
                    result.candidates[0].content && result.candidates[0].content.parts && 
                    result.candidates[0].content.parts.length > 0) {
                    
                    const generatedText = result.candidates[0].content.parts[0].text;
                    debugLog("Successfully received generated text (first 100 chars):", generatedText.substring(0, 100) + "...");
                    return generatedText;
                } else {
                    debugLog("Unexpected API response format:", result);
                    return "I received an unexpected response format. Please try again.";
                }
            } catch (error) {
                debugLog("Error calling Gemini API:", error.message);
                
                if (error.message.includes("Failed to fetch") || error.message.includes("NetworkError")) {
                    return "I'm having trouble connecting to my language model service. This might be due to network issues or service availability. Please try again later.";
                }
                
                return "I encountered an error while trying to answer your question. Please try again.";
            }
        }

        // Function to add a message to the chat
        function addMessage(text, sender) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.innerHTML = text;
            
            // Clear any previous messages with the same float direction
            const clearDiv = document.createElement('div');
            clearDiv.className = 'clearfix';
            messagesDiv.appendChild(clearDiv);
            
            messagesDiv.appendChild(messageDiv);
            
            // Another clearfix after the message
            const clearDiv2 = document.createElement('div');
            clearDiv2.className = 'clearfix';
            messagesDiv.appendChild(clearDiv2);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            return messageDiv;
        }

        // Improved sendMessage function
        async function sendMessage() {
            const userInput = document.getElementById('user-input');
            const inputText = userInput.value.trim();
            
            // First check for command - this should be the first thing we do
            if (inputText.toLowerCase() === "!test api") {
                userInput.value = '';
                testGeminiAPI();
                return;
            }
            
            if (!inputText) return;
            
            debugLog("User input:", inputText);
            
            // Save to conversation state before clearing
            conversationState.lastQuery = inputText;
            
            // Add user message
            addMessage(inputText, 'user');
            
            // Add to conversation history
            conversationHistory.push({role: "user", content: inputText});
            debugLog("Updated conversation history:", conversationHistory.length + " messages");
            
            // Clear input
            userInput.value = '';
            
            // Show typing indicator
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.textContent = 'Typing...';
            typingIndicator.id = 'typing-indicator';
            document.getElementById('messages').appendChild(typingIndicator);
            document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
            
            // Ensure properties are loaded
            if (!propertiesLoaded) {
                debugLog("Properties not loaded, loading now...");
                await loadProperties();
            }

            // Extract criteria to check for people-based query
            const criteria = extractSearchCriteria(inputText);
            
            // NEW: If this is a people-based query, use Gemini to convert people to sqm
            if (criteria.peopleCount) {
                try {
                    debugLog("People-based query detected, using Gemini to convert to sqm");
                    
                    // Call Gemini API to convert people to sqm
                    const conversionResponse = await callGeminiAPIForPeopleConversion(criteria.peopleCount, criteria.type || "office");
                    
                    // Update criteria with the sqm conversion
                    if (conversionResponse.minSize && conversionResponse.maxSize) {
                        debugLog(`Converted ${criteria.peopleCount} people to ${conversionResponse.minSize}-${conversionResponse.maxSize} sqm`);
                        
                        // Update criteria with the size range
                        delete criteria.size; // Remove any size if present
                        criteria.minSize = conversionResponse.minSize;
                        criteria.maxSize = conversionResponse.maxSize;
                        
                        // Remove the peopleCount flag
                        delete criteria.peopleCount;
                        
                        // Update conversation state
                        conversationState.currentSearchCriteria = {...criteria};
                        
                        // Search with the updated criteria
                        const matchedProperties = enhancedSearchProperties(criteria);
                        
                        if (matchedProperties.length > 0) {
                            // Format the explanation
                            const conversionExplanation = isCzech(inputText)
                                ? `Pro ${criteria.peopleCount} osob byste potřebovali přibližně ${criteria.minSize}-${criteria.maxSize} m². Našel jsem tyto možnosti:`
                                : `For ${criteria.peopleCount} people, you would need approximately ${criteria.minSize}-${criteria.maxSize} sqm. Here are the options I found:`;
                            
                            // Generate property listings HTML
                            const propertyListingsHTML = generatePropertyListingHTML(matchedProperties, conversationState.offset, 5);
                            
                            // Add pagination information
                            const paginationHTML = isCzech(inputText)
                                ? `<br>Zobrazuji 1-${Math.min(5, matchedProperties.length)} z ${matchedProperties.length} nalezených nemovitostí.${matchedProperties.length > 5 ? ' Napište "více" pro zobrazení dalších.' : ''}`
                                : `<br>Showing 1-${Math.min(5, matchedProperties.length)} of ${matchedProperties.length} matching properties.${matchedProperties.length > 5 ? ' Type "more" to see more.' : ''}`;
                            
                            // Add follow-up prompt
                            const followupHTML = isCzech(inputText)
                                ? `<br><br>Přejete si více informací o některé z těchto nemovitostí nebo chcete upřesnit vyhledávání?`
                                : `<br><br>Would you like more details about any of these properties or would you like to refine your search?`;
                            
                            // Combine everything
                            const fullResponse = conversionExplanation + "<br><br>" + propertyListingsHTML + paginationHTML + followupHTML;
                            
                            // Display the response
                            if (document.getElementById('typing-indicator')) {
                                document.getElementById('typing-indicator').remove();
                            }
                            
                            // Update last shown properties
                            conversationState.lastShownProperties = matchedProperties.slice(0, 5).map(p => p.name);
                            
                            addMessage(fullResponse, 'bot');
                            conversationHistory.push({role: "assistant", content: fullResponse});
                            return;
                        }
                    }
                } catch (error) {
                    debugLog("Error processing people-based query:", error.message);
                    // Continue with normal flow if there's an error
                }
            }

            // STRATEGY: First generate a local response that we can fall back to
            const fallbackResponse = generateLocalResponse(inputText);
            debugLog("Generated fallback response");
            
            // If our fallback found property matches, prioritize it for instant response
            const containsPropertyItems = fallbackResponse.includes("property-item");
            
            if (containsPropertyItems) {
                debugLog("Fallback contains property matches, using it immediately");
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Save this response to conversation state
                conversationState.lastResponse = fallbackResponse;
                
                addMessage(fallbackResponse, 'bot');
                
                // Add to conversation history
                conversationHistory.push({role: "assistant", content: fallbackResponse});
                return;
            }
            
            // If fallback didn't find properties, try Gemini API
            try {
                debugLog("Attempting to use Gemini API");
                // Try to call Gemini API with timeout
                const apiPromise = callGeminiAPI(inputText);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => {
                        debugLog("API call timed out after 20 seconds");
                        reject(new Error("API call timed out"))
                    }, 20000)
                );
                
                const aiResponse = await Promise.race([apiPromise, timeoutPromise]);
                debugLog("Received API response");
                
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Save this response to conversation state
                conversationState.lastResponse = aiResponse;
                
                addMessage(aiResponse, 'bot');
                
                // Add to conversation history
                conversationHistory.push({role: "assistant", content: aiResponse});
            } catch (error) {
                // Use the fallback response we already generated
                debugLog("Error calling AI, using fallback:", error.message);
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Save this response to conversation state
                conversationState.lastResponse = fallbackResponse;
                
                addMessage(fallbackResponse, 'bot');
                
                // Add to conversation history
                conversationHistory.push({role: "assistant", content: fallbackResponse});
            }
        }

        // Special debugging function for API testing
        function testGeminiAPI() {
            // Important: Don't add to conversation history
            debugLog("Testing Gemini API connection as a special command");
            
            // Clear any existing typing indicators
            if (document.getElementById('typing-indicator')) {
                document.getElementById('typing-indicator').remove();
            }
            
            // Add a message to the chat about the test
            const testMessage = addMessage("Testing Gemini API connection...", 'bot');
            
            // Show typing indicator
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.textContent = 'Testing API...';
            typingIndicator.id = 'typing-indicator';
            document.getElementById('messages').appendChild(typingIndicator);
            
            // Try a simple call to the Gemini model
            fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            role: "user",
                            parts: [{ text: "Hello, this is a test." }]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.7,
                        maxOutputTokens: 100
                    }
                })
            })
            .then(response => {
                debugLog("API test response status:", response.status);
                return response.text().then(text => {
                    return { status: response.status, text: text };
                });
            })
            .then(({ status, text }) => {
                debugLog("API test response:", text);
                
                let testResult = "";
                
                try {
                    if (status >= 200 && status < 300) {
                        const jsonResponse = JSON.parse(text);
                        testResult = "✅ Gemini API is accessible and responded successfully!";
                        
                        if (jsonResponse.candidates && jsonResponse.candidates.length > 0 && 
                            jsonResponse.candidates[0].content && jsonResponse.candidates[0].content.parts && 
                            jsonResponse.candidates[0].content.parts.length > 0) {
                            const modelResponse = jsonResponse.candidates[0].content.parts[0].text;
                            testResult += `<br><br>Model response: "${modelResponse.substring(0, 100)}${modelResponse.length > 100 ? '...' : ''}"`;
                        }
                    } else {
                        if (text.includes("API key not valid")) {
                            testResult = "❌ Authentication failed. Your API key may be invalid or expired.";
                        } else if (status === 403) {
                            testResult = "❌ Access denied to Gemini API (403). Check your API key permissions.";
                        } else if (status === 404) {
                            testResult = "❌ Gemini API endpoint not found (404). The API URL may be incorrect.";
                        } else {
                            testResult = `❌ Error accessing Gemini API: ${text}`;
                        }
                    }
                } catch (error) {
                    testResult = `❌ Error parsing API response: ${error.message}<br><br>Raw response (status ${status}): ${text}`;
                }
                
                return testResult;
            })
            .then(finalResult => {
                // Remove typing indicator
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Display the test result
                addMessage(`<strong>Gemini API Test Results:</strong><br><br>${finalResult}`, 'bot');
            })
            .catch(error => {
                debugLog("API test error:", error);
                
                // Remove typing indicator
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Display error message
                addMessage(`<strong>API Test Failed:</strong><br><br>❌ ${error.message}`, 'bot');
            });
        }

        // Add listener for debug command
        document.getElementById('user-input').addEventListener('input', function(e) {
            if (e.target.value.trim().toLowerCase() === "!test api") {
                e.target.style.backgroundColor = "#e8f4ff";
            } else {
                e.target.style.backgroundColor = "";
            }
        });
<div class="chat-container">
        <!-- ... -->
    </div>
    
    <script>
        // Original JavaScript code
        const DEBUG_MODE = true;
        let properties = [];
        // ... all your original variables and functions
        
        // callGeminiAPI function and other existing functions
        async function callGeminiAPI(userInput) {
            // ...
        }
        
        // All the new functions from step 2
        function handleSuggestionClick(suggestion) {
            // ...
        }
        
        function handleRefinementClick(refinementType, value) {
            // ...
        }
        
        // ... other new functions ...
        
        // THIS IS WHERE STEP 4 GOES - ADD THIS CODE AT THE END:
        // This function intercepts button clicks and prevents them from being added to the message history twice
        document.addEventListener('click', function(e) {
            if (e.target && e.target.matches('.suggestion-button, .refinement-button, .action-button')) {
                e.preventDefault();
                // The actual functionality is handled via onclick attributes on the buttons
            }
        });
        
        // Add handleSuggestionClick and other functions to window so they can be called from onclick
        window.handleSuggestionClick = handleSuggestionClick;
        window.handleRefinementClick = handleRefinementClick;
        window.handleShowMore = handleShowMore;
        window.startProgressiveConversation = startProgressiveConversation;
        window.handleProgressiveAnswer = handleProgressiveAnswer;
    </script>
</body>
</html>
