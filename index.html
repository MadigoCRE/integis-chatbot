<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integis Property Assistant</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: transparent;
        }
        
        .chat-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        
        .chat-header {
            background-color: #0078d4;
            color: white;
            padding: 15px;
            font-weight: bold;
            text-align: center;
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: #f8f8f8;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            clear: both;
        }
        
        .user-message {
            background-color: #0078d4;
            color: white;
            float: right;
        }
        
        .bot-message {
            background-color: #e9e9e9;
            color: #333;
            float: left;
        }
        
        .input-container {
            display: flex;
            padding: 15px;
            background-color: #fff;
            border-top: 1px solid #eee;
        }
        
        #user-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 14px;
        }
        
        #send-button {
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 0 20px;
            cursor: pointer;
            font-weight: bold;
        }
        
        #send-button:hover {
            background-color: #0069b8;
        }
        
        .property-item {
            margin: 12px 0;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(0, 120, 212, 0.05);
            border-left: 3px solid #0078d4;
        }
        
        .property-name {
            font-weight: bold;
            color: #0078d4;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .property-details {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .property-detail {
            background-color: #f0f0f0;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.9em;
        }
        
        .typing-indicator {
            background-color: #e9e9e9;
            color: #666;
            padding: 8px 15px;
            border-radius: 18px;
            margin-bottom: 15px;
            display: inline-block;
            float: left;
            clear: both;
        }
        
        /* For iframe embedding, ensure proper sizing */
        @media (max-width: 500px) {
            .chat-container {
                max-width: 100%;
                max-height: 100%;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
        
        /* Clear floats after messages */
        .clearfix::after {
            content: "";
            clear: both;
            display: table;
        }
        
        /* Reset button */
        #reset-chat {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.8;
        }
        
        #reset-chat:hover {
            opacity: 1;
        }
        
        /* Debug panel for development */
        .debug-panel {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 200px;
            background-color: rgba(0,0,0,0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 10px;
            overflow-y: auto;
            z-index: 1000;
            display: none; /* Hidden by default, enable for debugging */
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            Integis Property Assistant
            <button id="reset-chat">New Chat</button>
        </div>
        <div id="messages" class="messages-container"></div>
        <div class="input-container">
            <input type="text" id="user-input" placeholder="Ask about our properties...">
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <!-- Debug panel (for development) -->
    <div id="debug-panel" class="debug-panel"></div>

    <script>
        // Debug flag - set to true to show debug panel and logs
        const DEBUG_MODE = true;
        
        // Initialize properties array
        let properties = [];
        let propertiesLoaded = false;
        
        // Conversation history - store the entire conversation
        let conversationHistory = [];

        // Conversation state - NEW ADDITION to track state across interactions
        let conversationState = {
            currentSearchCriteria: null,
            lastShownProperties: [],
            offset: 0, // For pagination of results
            lastQuery: "",
            lastResponse: ""
        };

        // Hugging Face configuration - Updated with correct model ID
        const HUGGING_FACE_TOKEN = "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";
        const MODEL_ID = "meta-llama/Llama-2-7b-chat-hf"; // Model ID

        // Debug logger function
        function debugLog(message, obj = null) {
            if (DEBUG_MODE) {
                console.log(message, obj || '');
                
                const panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.style.display = 'block';
                    
                    const logEntry = document.createElement('div');
                    logEntry.textContent = `${new Date().toISOString().substr(11, 8)} - ${message}`;
                    
                    if (obj) {
                        const objStr = typeof obj === 'string' ? obj : JSON.stringify(obj);
                        if (objStr.length > 200) {
                            logEntry.textContent += ` ${objStr.substr(0, 200)}...`;
                        } else {
                            logEntry.textContent += ` ${objStr}`;
                        }
                    }
                    
                    panel.appendChild(logEntry);
                    panel.scrollTop = panel.scrollHeight;
                    
                    // Limit entries to prevent browser slowdown
                    while (panel.childElementCount > 100) {
                        panel.removeChild(panel.firstChild);
                    }
                }
            }
        }

        // Function to load properties from JSON file
        async function loadProperties() {
            try {
                debugLog("Loading properties from JSON file...");
                const loadingMessage = addMessage("Loading property listings...", 'bot');
                
                const response = await fetch('properties.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                properties = await response.json();
                propertiesLoaded = true;
                
                debugLog(`Successfully loaded ${properties.length} properties`);
                loadingMessage.innerHTML = `Property listings loaded successfully! I now have information about ${properties.length} properties.`;
                
                return true;
            } catch (error) {
                debugLog("Error loading properties:", error.message);
                const loadingMessage = document.querySelector('.bot-message:last-child');
                if (loadingMessage) {
                    loadingMessage.innerHTML = "I'm having trouble loading the property listings. Please try again later.";
                }
                return false;
            }
        }

        // Add welcome message and load properties when page loads
        window.addEventListener('load', async function() {
            // Add welcome message
            const welcomeMessage = "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?";
            addMessage(welcomeMessage, 'bot');
            
            // Add to conversation history
            conversationHistory.push({role: "assistant", content: welcomeMessage});
            
            // Load properties
            await loadProperties();
            
            if (DEBUG_MODE) {
                debugLog("Debug mode enabled. Showing debug panel.");
                document.getElementById('debug-panel').style.display = 'block';
            }
        });

        // Reset chat button - UPDATED to clear conversation state
        document.getElementById('reset-chat').addEventListener('click', function() {
            // Clear conversation history
            conversationHistory = [];
            
            // Reset conversation state
            conversationState = {
                currentSearchCriteria: null,
                lastShownProperties: [],
                offset: 0,
                lastQuery: "",
                lastResponse: ""
            };
            
            // Clear messages
            document.getElementById('messages').innerHTML = '';
            
            // Add welcome message
            const welcomeMessage = "Hello! I'm your Integis property assistant. How can I help you find the perfect commercial property today?";
            addMessage(welcomeMessage, 'bot');
            
            // Add to conversation history
            conversationHistory.push({role: "assistant", content: welcomeMessage});
            
            debugLog("Chat reset, conversation state cleared");
        });

        // Send button click event
        document.getElementById('send-button').addEventListener('click', sendMessage);

        // Enter key press event
        document.getElementById('user-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // NEW FUNCTION: Improved follow-up detection
        function isFollowUpQuestion(userInput) {
            // First, check for obvious follow-up phrases
            const followUpPhrases = /more|additional|another|further|similar|like that|such|tell me more|show more|any other|else|next|other|další|více|ještě|také|další|podobné/i;
            
            if (followUpPhrases.test(userInput)) {
                return true;
            }
            
            // Check for very short queries that likely reference previous context
            if (userInput.split(/\s+/).length < 4 && conversationState.currentSearchCriteria) {
                return true;
            }
            
            // Check for queries that only specify one parameter but we have other parameters saved
            const hasOnlySize = /\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)/i.test(userInput) && 
                               !/office|retail|industrial|prague|brno|ostrava|kancelář|obchod|průmysl/i.test(userInput);
            
            const hasOnlyLocation = /prague|praha|brno|ostrava/i.test(userInput) && 
                                   !/\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)|office|retail|industrial|kancelář|obchod|průmysl/i.test(userInput);
            
            const hasOnlyType = /office|retail|industrial|kancelář|obchod|průmysl/i.test(userInput) && 
                                !/\d+\s*(?:sq\s*m|sqm|square meter|m2|metr)|prague|praha|brno|ostrava/i.test(userInput);
            
            if ((hasOnlySize || hasOnlyLocation || hasOnlyType) && conversationState.currentSearchCriteria) {
                return true;
            }
            
            return false;
        }

        // UPDATED: Enhanced property search function
        function enhancedSearchProperties(criteria) {
            debugLog("Searching properties with criteria:", criteria);
            let results = [...properties];
            
            // Filter by property type
            if (criteria.type) {
                const typeKeywords = criteria.type.toLowerCase().split(/\s+/);
                results = results.filter(p => {
                    if (!p.type) return false;
                    const propertyType = p.type.toLowerCase();
                    return typeKeywords.some(keyword => propertyType.includes(keyword));
                });
                debugLog(`After type filter: ${results.length} properties remaining`);
            }
            
            // Filter by location (city or district)
            if (criteria.location) {
                const locationKeywords = criteria.location.toLowerCase().split(/\s+/);
                results = results.filter(p => {
                    const propertyLocation = (p.location || "").toLowerCase();
                    const propertyCity = (p.city || "").toLowerCase();
                    const propertyDistrict = (p.district || "").toLowerCase();
                    
                    return locationKeywords.some(keyword => 
                        propertyLocation.includes(keyword) || 
                        propertyCity.includes(keyword) || 
                        propertyDistrict.includes(keyword)
                    );
                });
                debugLog(`After location filter: ${results.length} properties remaining`);
            }
            
            // Enhanced size filtering logic
            const handleSizeFiltering = () => {
                if (criteria.size) {
                    // Target size with tolerance
                    const targetSize = parseInt(criteria.size);
                    if (!isNaN(targetSize)) {
                        // More precise size range - 20% deviation
                        const minSize = targetSize * 0.8;
                        const maxSize = targetSize * 1.2;
                        
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                        });
                        debugLog(`After size (approx ${criteria.size}) filter: ${results.length} properties remaining`);
                    }
                } else {
                    // Handle explicit min/max size if provided
                    if (criteria.maxSize) {
                        const maxSize = parseInt(criteria.maxSize);
                        if (!isNaN(maxSize)) {
                            results = results.filter(p => {
                                const propertySize = parseInt(p.size);
                                return !isNaN(propertySize) && propertySize <= maxSize;
                            });
                            debugLog(`After maxSize (${criteria.maxSize}) filter: ${results.length} properties remaining`);
                        }
                    }
                    
                    if (criteria.minSize) {
                        const minSize = parseInt(criteria.minSize);
                        if (!isNaN(minSize)) {
                            results = results.filter(p => {
                                const propertySize = parseInt(p.size);
                                return !isNaN(propertySize) && propertySize >= minSize;
                            });
                            debugLog(`After minSize (${criteria.minSize}) filter: ${results.length} properties remaining`);
                        }
                    }
                }
            };
            
            handleSizeFiltering();
            
            // Filter by price
            if (criteria.price) {
                results = results.filter(p => {
                    if (!p.price) return false;
                    return p.price.toLowerCase().includes(criteria.price.toLowerCase());
                });
                debugLog(`After price filter: ${results.length} properties remaining`);
            }
            
            // Filter by availability
            if (criteria.available) {
                const availableKeywords = criteria.available.toLowerCase().split(/\s+/);
                results = results.filter(p => {
                    if (!p.available) return false;
                    const propertyAvailable = p.available.toLowerCase();
                    return availableKeywords.some(keyword => propertyAvailable.includes(keyword));
                });
                debugLog(`After availability filter: ${results.length} properties remaining`);
            }
            
            // Exclude specific properties if needed
            if (criteria.excludeNames && criteria.excludeNames.length > 0) {
                results = results.filter(p => !criteria.excludeNames.includes(p.name));
                debugLog(`After exclusion filter: ${results.length} properties remaining`);
            }
            
            // If no results and we have size criteria, try with more relaxed size constraints
            if (results.length === 0 && (criteria.size || criteria.minSize || criteria.maxSize)) {
                debugLog("No results with strict size criteria, trying with relaxed size constraints");
                
                // Reset results
                results = [...properties];
                
                // Reapply non-size filters
                if (criteria.type) {
                    const typeKeywords = criteria.type.toLowerCase().split(/\s+/);
                    results = results.filter(p => {
                        if (!p.type) return false;
                        const propertyType = p.type.toLowerCase();
                        return typeKeywords.some(keyword => propertyType.includes(keyword));
                    });
                }
                
                if (criteria.location) {
                    const locationKeywords = criteria.location.toLowerCase().split(/\s+/);
                    results = results.filter(p => {
                        const propertyLocation = (p.location || "").toLowerCase();
                        const propertyCity = (p.city || "").toLowerCase();
                        const propertyDistrict = (p.district || "").toLowerCase();
                        
                        return locationKeywords.some(keyword => 
                            propertyLocation.includes(keyword) || 
                            propertyCity.includes(keyword) || 
                            propertyDistrict.includes(keyword)
                        );
                    });
                }
                
                // Apply more relaxed size constraints (30% instead of 20%)
                if (criteria.size) {
                    const targetSize = parseInt(criteria.size);
                    if (!isNaN(targetSize)) {
                        const minSize = targetSize * 0.7;
                        const maxSize = targetSize * 1.3;
                        
                        results = results.filter(p => {
                            const propertySize = parseInt(p.size);
                            return !isNaN(propertySize) && propertySize >= minSize && propertySize <= maxSize;
                        });
                        debugLog(`After relaxed size filter: ${results.length} properties remaining`);
                    }
                } else {
                    // Relax explicit min/max by 10%
                    if (criteria.maxSize) {
                        const maxSize = parseInt(criteria.maxSize) * 1.1;
                        if (!isNaN(maxSize)) {
                            results = results.filter(p => {
                                const propertySize = parseInt(p.size);
                                return !isNaN(propertySize) && propertySize <= maxSize;
                            });
                        }
                    }
                    
                    if (criteria.minSize) {
                        const minSize = parseInt(criteria.minSize) * 0.9;
                        if (!isNaN(minSize)) {
                            results = results.filter(p => {
                                const propertySize = parseInt(p.size);
                                return !isNaN(propertySize) && propertySize >= minSize;
                            });
                        }
                    }
                }
                
                debugLog(`After relaxed size criteria: ${results.length} properties remaining`);
            }
            
            debugLog(`Final search results: ${results.length} properties`);
            return results;
        }

        // UPDATED: Improved local response generator with better context handling
        function generateLocalResponse(userInput) {
            debugLog("Generating local response for:", userInput);
            userInput = userInput.toLowerCase();
            
            // Check if properties are loaded
            if (!propertiesLoaded || properties.length === 0) {
                debugLog("Properties not loaded, returning error message");
                return "I don't have access to our property listings at the moment. Please try again later or contact Integis directly for assistance.";
            }
            
            // Determine language for response (simple heuristic)
            const isCzech = /[áčďéěíňóřšťúůýž]/i.test(userInput);
            debugLog("Language detection - isCzech:", isCzech);
            
            // Check if this is a follow-up question
            const isFollowUp = isFollowUpQuestion(userInput);
            debugLog("Is follow-up question:", isFollowUp);
            
            // Create search criteria object - IMPORTANT: This is where we maintain context
            let criteria = {};
            
            // If follow-up, start with previous criteria
            if (isFollowUp && conversationState.currentSearchCriteria) {
                criteria = {...conversationState.currentSearchCriteria};
                debugLog("Using previous search criteria as base:", criteria);
                
                // For pagination requests, keep the same criteria but update offset
                if (/more|další|show more|ukázat více/i.test(userInput)) {
                    conversationState.offset += 5; // Show next 5 results
                    debugLog("Pagination request - updating offset to:", conversationState.offset);
                }
            } else {
                // Reset offset for new searches
                conversationState.offset = 0;
            }
            
            // Extract new criteria from current input
            // These will override or supplement previous criteria
            
            // Check for property type
            if (/office|kancelář/i.test(userInput)) {
                criteria.type = "office";
            } else if (/retail|obchod/i.test(userInput)) {
                criteria.type = "retail";
            } else if (/industrial|průmysl|sklad/i.test(userInput)) {
                criteria.type = "industrial";
            }
            
            // Check for location
            if (/prague|praha/i.test(userInput)) {
                criteria.location = "Prague";
                
                // Check for Prague district
                const pragueDistrictMatch = userInput.match(/prague\s*(\d+)|praha\s*(\d+)/i);
                if (pragueDistrictMatch && (pragueDistrictMatch[1] || pragueDistrictMatch[2])) {
                    criteria.location = `Prague ${pragueDistrictMatch[1] || pragueDistrictMatch[2]}`;
                }
            } else if (/brno/i.test(userInput)) {
                criteria.location = "Brno";
            } else if (/ostrava/i.test(userInput)) {
                criteria.location = "Ostrava";
            }
            
            // Check for size
            const sizeMatch = userInput.match(/(\d+)\s*(?:sq\s*m|sqm|square meter|m2|metr)/i);
            if (sizeMatch) {
                criteria.size = sizeMatch[1];
            }
            
            // Check for "less than" or "under" size specification
            const underSizeMatch = userInput.match(/(?:less than|under|smaller than|max|maximum|do|méně než|pod|maximálně)\s*(\d+)/i);
            if (underSizeMatch) {
                criteria.maxSize = underSizeMatch[1];
            }
            
            // Check for "more than" or "over" size specification
            const overSizeMatch = userInput.match(/(?:more than|over|larger than|min|minimum|nad|více než|minimálně)\s*(\d+)/i);
            if (overSizeMatch) {
                criteria.minSize = overSizeMatch[1];
            }
            
            // Check for price mentions
            if (/€|eur|euro|czk|kč|price|cost|rent|nájem/i.test(userInput)) {
                criteria.price = ""; // Just flag that price is important
            }
            
            // Check for availability mentions
            if (/available|now|immediately|ihned|dostupn/i.test(userInput)) {
                criteria.available = "now";
            } else if (/q[1-4]|quarter|quartal|kvartál|202[0-9]/i.test(userInput)) {
                criteria.available = ""; // Just flag that specific availability is important
            }
            
            // For requests to "show all" - start fresh with just the core criteria
            if (/show all|share all|all properties|all units|všechny|všechny jednotky/i.test(userInput)) {
                // Keep only the most important criteria (type, location, size) and reset pagination
                const coreCriteria = {};
                if (criteria.type) coreCriteria.type = criteria.type;
                if (criteria.location) coreCriteria.location = criteria.location;
                if (criteria.size) coreCriteria.size = criteria.size;
                if (criteria.maxSize) coreCriteria.maxSize = criteria.maxSize;
                if (criteria.minSize) coreCriteria.minSize = criteria.minSize;
                
                criteria = coreCriteria;
                conversationState.offset = 0;
                debugLog("'Show all' request - using core criteria only:", criteria);
            }
            
            // IMPORTANT: Update the global conversation state with the new criteria
            conversationState.currentSearchCriteria = {...criteria};
            debugLog("Updated conversation state with new criteria:", conversationState.currentSearchCriteria);
            
            // Search for matching properties with enhanced search function
            let matchedProperties = enhancedSearchProperties(criteria);
            
            // Store the properties we've shown for follow-up questions
            if (matchedProperties.length > 0) {
                const propertiesToShow = matchedProperties.slice(
                    conversationState.offset, 
                    conversationState.offset + 5
                );
                
                // Update last shown properties
                conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
                debugLog("Updated last shown properties:", conversationState.lastShownProperties);
            }
            
            // Generate response
            if (matchedProperties.length > 0) {
                debugLog(`Generating response with ${matchedProperties.length} matching properties (offset: ${conversationState.offset})`);
                
                let response = "";
                
                if (isFollowUp && /more|další|show more|ukázat více/i.test(userInput) && conversationState.offset > 0) {
                    response = isCzech 
                        ? `Ano, zde jsou další nemovitosti, které splňují vaše kritéria:<br><br>`
                        : `Yes, here are more properties that match your criteria:<br><br>`;
                } else if (isFollowUp) {
                    if (criteria.location && criteria.type && criteria.size) {
                        response = isCzech 
                            ? `Našel jsem tyto ${criteria.type} prostory v lokalitě ${criteria.location} o velikosti kolem ${criteria.size} m²:<br><br>`
                            : `I found these ${criteria.type} spaces in ${criteria.location} with a size around ${criteria.size} sqm:<br><br>`;
                    } else {
                        response = isCzech 
                            ? `Na základě upřesněných kritérií jsem našel tyto nemovitosti:<br><br>`
                            : `Based on your refined criteria, I found these properties:<br><br>`;
                    }
                } else {
                    response = isCzech 
                        ? `Na základě vašeho dotazu jsem našel tyto nemovitosti, které by vás mohly zajímat:<br><br>`
                        : `Based on your query, I found these properties that might interest you:<br><br>`;
                }
                
                // Get the relevant slice for pagination
                const propertiesToShow = matchedProperties.slice(
                    conversationState.offset, 
                    conversationState.offset + 5
                );
                
                // If no properties to show at current offset but we have matches
                if (propertiesToShow.length === 0 && matchedProperties.length > 0) {
                    // Reset offset to 0 and show the first page
                    conversationState.offset = 0;
                    const propertiesToShow = matchedProperties.slice(0, 5);
                    
                    response = isCzech 
                        ? `Došli jsme na konec výsledků. Zde jsou znovu první nemovitosti:<br><br>`
                        : `We've reached the end of the results. Here are the first properties again:<br><br>`;
                        
                    conversationState.lastShownProperties = propertiesToShow.map(p => p.name);
                }
                
                // Format property items
                propertiesToShow.forEach(property => {
                    let propertyDetails = `<div class="property-item">
                        <div class="property-name">${property.name}</div>`;
                    
                    propertyDetails += `<div class="property-details">`;
                    
                    if (property.size) {
                        propertyDetails += `<span class="property-detail">${property.size} sqm</span>`;
                    }
                    
                    if (property.type) {
                        propertyDetails += `<span class="property-detail">${property.type}</span>`;
                    }
                    
                    if (property.price) {
                        propertyDetails += `<span class="property-detail">${property.price}</span>`;
                    }
                    
                    if (property.floor) {
                        propertyDetails += `<span class="property-detail">${property.floor}</span>`;
                    }
                    
                    // Use location if available, otherwise fallback to city and district
                    if (property.location) {
                        propertyDetails += `<span class="property-detail">${property.location}</span>`;
                    } else if (property.city) {
                        let locationText = property.city;
                        if (property.district) {
                            locationText += ` - ${property.district}`;
                        }
                        propertyDetails += `<span class="property-detail">${locationText}</span>`;
                    }
                    
                    if (property.available) {
                        propertyDetails += `<span class="property-detail">Available: ${property.available}</span>`;
                    }
                    
                    propertyDetails += `</div></div>`;
                    
                    response += propertyDetails;
                });
                
                // Add pagination information
                const remainingCount = matchedProperties.length - (conversationState.offset + propertiesToShow.length);
                if (remainingCount > 0) {
                    response += isCzech
                        ? `<br>Zobrazuji ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí. Napište "více" pro zobrazení dalších.`
                        : `<br>Showing ${conversationState.offset + 1}-${conversationState.offset + propertiesToShow.length} of ${matchedProperties.length} matching properties. Type "more" to see more.`;
                } else {
                    response += isCzech
                        ? `<br>Zobrazuji ${propertiesToShow.length} z ${matchedProperties.length} nalezených nemovitostí.`
                        : `<br>Showing ${propertiesToShow.length} of ${matchedProperties.length} matching properties.`;
                }
                
                // Add follow-up prompt
                response += isCzech
                    ? `<br><br>Přejete si více informací o některé z těchto nemovitostí nebo chcete upřesnit vyhledávání?`
                    : `<br><br>Would you like more details about any of these properties or would you like to refine your search?`;
                    
                return response;
            } else {
                debugLog("No matching properties found");
                
                let noMatchResponse = "";
                
                if (isFollowUp) {
                    noMatchResponse = isCzech
                        ? `Bohužel jsem nenašel žádné nemovitosti, které by odpovídaly těmto upřesněným požadavkům. Možná zkuste jiné parametry?`
                        : `I couldn't find any properties matching these refined criteria. Perhaps try different parameters?`;
                        
                    // Suggest alternatives by relaxing constraints
                    if (criteria.size && criteria.location && criteria.type) {
                        // Try without size constraint
                        const withoutSizeSearch = {...criteria};
                        delete withoutSizeSearch.size;
                        delete withoutSizeSearch.maxSize;
                        delete withoutSizeSearch.minSize;
                        
                        const sizeAlternatives = enhancedSearchProperties(withoutSizeSearch);
                        
                        if (sizeAlternatives.length > 0) {
                            noMatchResponse += isCzech
                                ? `<br><br>Našel jsem však ${sizeAlternatives.length} ${criteria.type} nemovitostí v lokalitě ${criteria.location} bez omezení velikosti. Přejete si je zobrazit?`
                                : `<br><br>However, I found ${sizeAlternatives.length} ${criteria.type} properties in ${criteria.location} without size restrictions. Would you like to see them?`;
                        }
                    }
                } else {
                    noMatchResponse = isCzech
                        ? `Bohužel jsem nenašel přesné shody pro vaše kritéria z našich ${properties.length} nemovitostí. Můžete zkusit obecnější vyhledávání? Například se můžete zeptat na "kancelářské prostory v Praze" nebo "obchodní prostory kolem 800 sqm".`
                        : `I couldn't find exact matches for your criteria from our ${properties.length} properties. Could you try a more general search? For example, you can ask about "office space in Prague" or "retail space around 800 sqm".`;
                }
                
                return noMatchResponse;
            }
        }

        // UPDATED: Hugging Face API call with improved context
        async function callHuggingFaceAPI(userInput) {
            debugLog("Starting Hugging Face API call for input:", userInput);
            
            // Check if properties are loaded
            if (!propertiesLoaded || properties.length === 0) {
                debugLog("Properties not loaded, returning error message");
                return "I don't have access to our property listings at the moment. Please try again later or ask general questions about commercial real estate.";
            }
            
            // Format properties as text for the prompt (limited to keep size manageable)
            let propertiesText = "";
            properties.slice(0, 20).forEach(property => { // Reduced to 20 properties
                let detailsText = `- ${property.name}: ${property.size} sqm ${property.type || ""}`;
                
                if (property.price) {
                    detailsText += `, ${property.price}`;
                }
                
                if (property.location) {
                    detailsText += ` in ${property.location}`;
                } else if (property.city) {
                    detailsText += ` in ${property.city}`;
                    if (property.district) {
                        detailsText += ` - ${property.district}`;
                    }
                }
                
                if (property.available) {
                    detailsText += `, available: ${property.available}`;
                }
                
                detailsText += "\n";
                propertiesText += detailsText;
            });

            // Format conversation history in the format expected by Llama-2-7b-chat-hf
            const formattedConversation = [];
            
            // Add system message with context preservation hints
            const systemMessage = {
                role: "system",
                content: `You are a professional commercial real estate assistant for Integis. Your job is to help clients find the perfect office, retail, or industrial space based on their needs. Be concise, professional, and helpful.

IMPORTANT INSTRUCTIONS:
1. ALWAYS maintain conversation context throughout the entire chat session
2. Remember previous searches and parameters
3. When user asks follow-up questions, add to their previous search criteria instead of replacing it
4. If they ask for "offices in Ostrava under 100 sqm" and then later ask "what about in Prague?", keep the type (office) and size (under 100 sqm) but change the location
5. When presenting properties, format them in an easy-to-read way
6. If you don't have information, be honest and offer to help in other ways
7. Always respond in the same language as the user (Czech or English)

CONVERSATION CONTEXT:
Current Search Criteria: ${JSON.stringify(conversationState.currentSearchCriteria || {})}
Last Shown Properties: ${JSON.stringify(conversationState.lastShownProperties || [])}

AVAILABLE PROPERTIES:
${propertiesText}`
            };
            
            formattedConversation.push(systemMessage);
            
            // Add past conversation messages (excluding the welcome message)
            // Make sure we add ALL relevant conversations for context
            for (let i = 1; i < conversationHistory.length; i++) {
                const message = conversationHistory[i];
                formattedConversation.push({
                    role: message.role === "user" ? "user" : "assistant",
                    content: message.content
                });
            }
            
            // Add the current user input
            formattedConversation.push({
                role: "user",
                content: userInput
            });
            
            debugLog("Prepared conversation messages for API:", formattedConversation.length + " messages");
            
            try {
                // IMPORTANT: Corrected API endpoint and parameters
                // Check if the model ID is correct - it should be exactly as specified on Hugging Face
                debugLog("Sending API request to Hugging Face endpoint:", `https://api-inference.huggingface.co/models/${MODEL_ID}`);
                
                const response = await fetch(`https://api-inference.huggingface.co/models/${MODEL_ID}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${HUGGING_FACE_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        inputs: {
                            text: `<s>[INST] ${systemMessage.content}\n\nCurrent User Question: ${userInput} [/INST]`
                        },
                        parameters: {
                            max_new_tokens: 400,
                            temperature: 0.7,
                            top_p: 0.95,
                            do_sample: true,
                            return_full_text: false
                        }
                    })
                });
                
                debugLog("API Response Status:", response.status);
                
                // Get response text for logging
                const responseText = await response.text();
                debugLog("API Response Text (first 100 chars):", responseText.substring(0, 100) + "...");
                
                // Parse the response
                let result;
                try {
                    result = JSON.parse(responseText);
                    debugLog("Parsed API response successfully");
                } catch (parseError) {
                    debugLog("Error parsing API response:", parseError.message);
                    if (responseText.includes("loading") || responseText.includes("queue")) {
                        debugLog("Model is loading or in queue");
                        return "I'm still warming up. Please try again in a few moments.";
                    }
                    if (responseText.includes("error")) {
                        debugLog("API returned an error message:", responseText);
                        return "I encountered an error connecting to my language model. Please try again.";
                    }
                    return "I encountered an error processing the response from my language model. Please try again.";
                }
                
                // Check for errors
                if (result.error) {
                    debugLog("API returned error in JSON format:", result.error);
                    if (result.error.includes("loading") || result.error.includes("queue")) {
                        return "I'm still warming up. Please try again in a few moments.";
                    }
                    throw new Error(result.error);
                }
                
                // Extract the generated text - format depends on the API response structure
                if (result && Array.isArray(result) && result[0] && result[0].generated_text) {
                    // First response format possibility
                    const generatedText = result[0].generated_text;
                    debugLog("Successfully received generated text (first 100 chars):", generatedText.substring(0, 100) + "...");
                    return generatedText;
                } else if (result && result.generated_text) {
                    // Second response format possibility 
                    debugLog("Successfully received generated text (first 100 chars):", result.generated_text.substring(0, 100) + "...");
                    return result.generated_text;
                } else if (result && result.choices && result.choices[0] && result.choices[0].message) {
                    // Third response format possibility (more like OpenAI format)
                    debugLog("Successfully received message content (first 100 chars):", result.choices[0].message.content.substring(0, 100) + "...");
                    return result.choices[0].message.content;
                } else {
                    // If we can't figure out the format, dump the result for debugging
                    debugLog("Unexpected API response format:", result);
                    return "I received an unexpected response format. Please try again.";
                }
            } catch (error) {
                debugLog("Error calling Hugging Face API:", error.message);
                if (error.message.includes("Failed to fetch") || error.message.includes("NetworkError")) {
                    return "I'm having trouble connecting to my language model service. This might be due to network issues or service availability. Please try again later.";
                }
                return "I encountered an error while trying to answer your question. Please try again.";
            }
        }

        // Function to add a message to the chat
        function addMessage(text, sender) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.innerHTML = text;
            
            // Clear any previous messages with the same float direction
            const clearDiv = document.createElement('div');
            clearDiv.className = 'clearfix';
            messagesDiv.appendChild(clearDiv);
            
            messagesDiv.appendChild(messageDiv);
            
            // Another clearfix after the message
            const clearDiv2 = document.createElement('div');
            clearDiv2.className = 'clearfix';
            messagesDiv.appendChild(clearDiv2);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            return messageDiv;
        }

        // UPDATED: Improved sendMessage function
        async function sendMessage() {
            const userInput = document.getElementById('user-input');
            if (!userInput.value.trim()) return;
            
            debugLog("User input:", userInput.value);
            
            // Save to conversation state before clearing
            conversationState.lastQuery = userInput.value;
            
            // Add user message
            addMessage(userInput.value, 'user');
            
            // Add to conversation history
            conversationHistory.push({role: "user", content: userInput.value});
            debugLog("Updated conversation history:", conversationHistory.length + " messages");
            
            // Clear input and store message
            const userMessage = userInput.value;
            userInput.value = '';
            
            // Show typing indicator
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.textContent = 'Typing...';
            typingIndicator.id = 'typing-indicator';
            document.getElementById('messages').appendChild(typingIndicator);
            document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
            
            // Ensure properties are loaded
            if (!propertiesLoaded) {
                debugLog("Properties not loaded, loading now...");
                await loadProperties();
            }

            // STRATEGY: First generate a local response that we can fall back to
            const fallbackResponse = generateLocalResponse(userMessage);
            debugLog("Generated fallback response");
            
            // If our fallback found property matches, prioritize it for instant response
            const containsPropertyItems = fallbackResponse.includes("property-item");
            
            if (containsPropertyItems) {
                debugLog("Fallback contains property matches, using it immediately");
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Save this response to conversation state
                conversationState.lastResponse = fallbackResponse;
                
                addMessage(fallbackResponse, 'bot');
                
                // Add to conversation history
                conversationHistory.push({role: "assistant", content: fallbackResponse});
                return;
            }
            
            // If fallback didn't find properties, try Hugging Face API
            try {
                debugLog("Attempting to use Hugging Face API");
                // Try to call Hugging Face API with timeout
                const apiPromise = callHuggingFaceAPI(userMessage);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => {
                        debugLog("API call timed out after 20 seconds");
                        reject(new Error("API call timed out"))
                    }, 20000)
                );
                
                const aiResponse = await Promise.race([apiPromise, timeoutPromise]);
                debugLog("Received API response");
                
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Save this response to conversation state
                conversationState.lastResponse = aiResponse;
                
                addMessage(aiResponse, 'bot');
                
                // Add to conversation history
                conversationHistory.push({role: "assistant", content: aiResponse});
            } catch (error) {
                // Use the fallback response we already generated
                debugLog("Error calling AI, using fallback:", error.message);
                if (document.getElementById('typing-indicator')) {
                    document.getElementById('typing-indicator').remove();
                }
                
                // Save this response to conversation state
                conversationState.lastResponse = fallbackResponse;
                
                addMessage(fallbackResponse, 'bot');
                
                // Add to conversation history
                conversationHistory.push({role: "assistant", content: fallbackResponse});
            }
        }
    </script>
</body>
</html>
